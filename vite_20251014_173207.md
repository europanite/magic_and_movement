<!-- P2M_REPORT -->
<!-- GENERATED at 2025-10-14 17:32:07 -->
# Project Export: vite

## Overview

- Root: `/home/skinner/magic_and_movement/vite`
- Files: **33**
- Total size: **3068769 bytes**
- Total LOC: 1436 | SLOC: 1134 | TODOs: 0

### Language mix
- typescript: 18
- plain: 10
- markdown: 1
- dockerfile: 1
- json: 1
- html: 1
- css: 1

### Top 12 largest files (bytes)
- `app/public/audio/title.mp3` — 1572393 bytes
- `app/public/audio/bgm.mp3` — 1339778 bytes
- `app/public/images/bullet.png` — 71431 bytes
- `app/src/scenes/MainScene.ts` — 21961 bytes
- `app/public/audio/bullet_timeout.mp3` — 9525 bytes
- `app/public/audio/character_destroy.mp3` — 9525 bytes
- `app/public/images/enemy_sheet.png` — 8041 bytes
- `app/public/images/witch_sheet.png` — 7286 bytes
- `app/src/entities/Base.ts` — 4203 bytes
- `app/src/logger.ts` — 3278 bytes
- `app/src/effects/DeathFX.ts` — 2727 bytes
- `app/src/entities/Bullet.ts` — 2552 bytes

### Top 12 longest files (LOC)
- `app/src/scenes/MainScene.ts` — 543 LOC
- `app/src/entities/Base.ts` — 145 LOC
- `app/src/style.css` — 98 LOC
- `app/src/entities/Bullet.ts` — 84 LOC
- `app/src/effects/DeathFX.ts` — 82 LOC
- `app/src/logger.ts` — 82 LOC
- `app/src/entities/CharacterBase.ts` — 62 LOC
- `app/index.html` — 51 LOC
- `app/src/scenes/TitleScene.ts` — 35 LOC
- `app/src/asr.ts` — 27 LOC
- `app/tsconfig.json` — 26 LOC
- `app/src/api.ts` — 25 LOC

### Project tree (included subset)
```
vite/
├── app/
│   ├── public/
│   │   ├── audio/
│   │   │   ├── bgm.mp3
│   │   │   ├── bullet_timeout.mp3
│   │   │   ├── character_destroy.mp3
│   │   │   └── title.mp3
│   │   ├── images/
│   │   │   ├── bullet.png
│   │   │   ├── enemy_sheet.png
│   │   │   └── witch_sheet.png
│   │   └── vite.svg
│   ├── src/
│   │   ├── audio/
│   │   │   ├── CharacterSound.ts
│   │   │   ├── EffectSound.ts
│   │   │   └── SoundManager.ts
│   │   ├── effects/
│   │   │   └── DeathFX.ts
│   │   ├── entities/
│   │   │   ├── Base.ts
│   │   │   ├── Boss.ts
│   │   │   ├── Bullet.ts
│   │   │   ├── CharacterBase.ts
│   │   │   ├── Enemy.ts
│   │   │   ├── Player.ts
│   │   │   └── Rock.ts
│   │   ├── scenes/
│   │   │   ├── MainScene.ts
│   │   │   └── TitleScene.ts
│   │   ├── api.ts
│   │   ├── asr.ts
│   │   ├── counter.ts
│   │   ├── logger.ts
│   │   ├── main.ts
│   │   ├── style.css
│   │   └── typescript.svg
│   ├── .gitignore
│   ├── index.html
│   └── tsconfig.json
├── Dockerfile
└── README.md
```

## Table of contents (files)

- 1. [app/.gitignore](#app-.gitignore)
- 2. [app/index.html](#app-index.html)
- 3. [app/public/audio/bgm.mp3](#app-public-audio-bgm.mp3)
- 4. [app/public/audio/bullet_timeout.mp3](#app-public-audio-bullet_timeout.mp3)
- 5. [app/public/audio/character_destroy.mp3](#app-public-audio-character_destroy.mp3)
- 6. [app/public/audio/title.mp3](#app-public-audio-title.mp3)
- 7. [app/public/images/bullet.png](#app-public-images-bullet.png)
- 8. [app/public/images/enemy_sheet.png](#app-public-images-enemy_sheet.png)
- 9. [app/public/images/witch_sheet.png](#app-public-images-witch_sheet.png)
- 10. [app/public/vite.svg](#app-public-vite.svg)
- 11. [app/src/api.ts](#app-src-api.ts)
- 12. [app/src/asr.ts](#app-src-asr.ts)
- 13. [app/src/audio/CharacterSound.ts](#app-src-audio-CharacterSound.ts)
- 14. [app/src/audio/EffectSound.ts](#app-src-audio-EffectSound.ts)
- 15. [app/src/audio/SoundManager.ts](#app-src-audio-SoundManager.ts)
- 16. [app/src/counter.ts](#app-src-counter.ts)
- 17. [app/src/effects/DeathFX.ts](#app-src-effects-DeathFX.ts)
- 18. [app/src/entities/Base.ts](#app-src-entities-Base.ts)
- 19. [app/src/entities/Boss.ts](#app-src-entities-Boss.ts)
- 20. [app/src/entities/Bullet.ts](#app-src-entities-Bullet.ts)
- 21. [app/src/entities/CharacterBase.ts](#app-src-entities-CharacterBase.ts)
- 22. [app/src/entities/Enemy.ts](#app-src-entities-Enemy.ts)
- 23. [app/src/entities/Player.ts](#app-src-entities-Player.ts)
- 24. [app/src/entities/Rock.ts](#app-src-entities-Rock.ts)
- 25. [app/src/logger.ts](#app-src-logger.ts)
- 26. [app/src/main.ts](#app-src-main.ts)
- 27. [app/src/scenes/MainScene.ts](#app-src-scenes-MainScene.ts)
- 28. [app/src/scenes/TitleScene.ts](#app-src-scenes-TitleScene.ts)
- 29. [app/src/style.css](#app-src-style.css)
- 30. [app/src/typescript.svg](#app-src-typescript.svg)
- 31. [app/tsconfig.json](#app-tsconfig.json)
- 32. [Dockerfile](#Dockerfile)
- 33. [README.md](#README.md)

---

## Files

<a id="app-.gitignore"></a>
### 1. `app/.gitignore`
- Size: 253 bytes | LOC: 24 | SLOC: 22 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: f97396057473

#### Brief
# Logs
logs

#### Auto Summary
# Logs

#### Content

```
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
```

<a id="app-index.html"></a>
### 2. `app/index.html`
- Size: 1232 bytes | LOC: 51 | SLOC: 46 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: 04a26b21fda8

#### Brief
<!doctype html>
<meta charset="utf-8" />

#### Auto Summary
<!doctype html>

#### Content

```html
<!doctype html>
<meta charset="utf-8" />
<title>Shout Demo</title>
<body style="margin:0;background:#3d1fc4">

  <!-- UIバー -->
  <div style="position:fixed;left:0;right:0;top:0;padding:8px 12px;
              background:#1f2530;color:#cfe8ff;font:14px/1 system-ui;display:flex;gap:8px;">
    <button id="btnMic" style="padding:6px 10px;">🎤 Start mic</button>
    <span id="micStatus">mic: idle</span>
  </div>

  <div 
    style="margin:0;"
  >
    <div 
      id="game-root" 
      style="
        background: #b61b1b;
        margin:0;
    ">
    </div>

    <!-- <pre 
      id="log" 
      style="
      margin: 0;
      background: #000;
      color: #0f0;
      font: 12px/1.4 monospace;
      padding: 6px;
      border-top: 1px solid #222;
    ">
    </pre> -->

    <pre 
      id="log" 
      style="
        margin: 0;
        background: #000;
        color: #0f0;
        font: 12px/1.4 monospace;
        padding: 6px;
        border-top: 1px solid #222;
        height: 160px;        /* ← 固定の最大高さ（お好みで調整） */
        overflow: hidden;     /* ← スクロール禁止。はみ出しは切り捨て */
      ">

</div>
  <script type="module" src="/src/main.ts"></script>
</body>
```

<a id="app-public-audio-bgm.mp3"></a>
### 3. `app/public/audio/bgm.mp3`
- Size: 1339778 bytes | LOC: 0 | SLOC: 0 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: 
#### Content

```
```

<a id="app-public-audio-bullet_timeout.mp3"></a>
### 4. `app/public/audio/bullet_timeout.mp3`
- Size: 9525 bytes | LOC: 0 | SLOC: 0 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: 
#### Content

```
```

<a id="app-public-audio-character_destroy.mp3"></a>
### 5. `app/public/audio/character_destroy.mp3`
- Size: 9525 bytes | LOC: 0 | SLOC: 0 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: 
#### Content

```
```

<a id="app-public-audio-title.mp3"></a>
### 6. `app/public/audio/title.mp3`
- Size: 1572393 bytes | LOC: 0 | SLOC: 0 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: 
#### Content

```
```

<a id="app-public-images-bullet.png"></a>
### 7. `app/public/images/bullet.png`
- Size: 71431 bytes | LOC: 0 | SLOC: 0 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: 
#### Content

```
```

<a id="app-public-images-enemy_sheet.png"></a>
### 8. `app/public/images/enemy_sheet.png`
- Size: 8041 bytes | LOC: 0 | SLOC: 0 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: 
#### Content

```
```

<a id="app-public-images-witch_sheet.png"></a>
### 9. `app/public/images/witch_sheet.png`
- Size: 7286 bytes | LOC: 0 | SLOC: 0 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: 
#### Content

```
```

<a id="app-public-vite.svg"></a>
### 10. `app/public/vite.svg`
- Size: 1497 bytes | LOC: 1 | SLOC: 1 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: f7f39d7237b7

#### Brief
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

#### Auto Summary
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid 

#### Content

```
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
```

<a id="app-src-api.ts"></a>
### 11. `app/src/api.ts`
- Size: 945 bytes | LOC: 25 | SLOC: 22 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: 678d687004d6

#### Brief
const BASE = import.meta.env.VITE_API_BASE as string | undefined;

#### Auto Summary
const BASE = import.meta.env.VITE_API_BASE as string | undefined;

#### Content

```typescript
const BASE = import.meta.env.VITE_API_BASE as string | undefined;

export async function createSession(): Promise<string> {
  if (!BASE) throw new Error("VITE_API_BASE not set");
  const r = await fetch(`${BASE}/commands/sessions`, { method: "POST" });
  const j = await r.json();
  return j.session_id as string;
}

export async function postRaw(sessionId: string, text: string) {
  if (!BASE) throw new Error("VITE_API_BASE not set");
  await fetch(`${BASE}/commands`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ session_id: sessionId, raw_text: text }),
  });
}

export async function pollNext(sessionId: string) {
  if (!BASE) throw new Error("VITE_API_BASE not set");
  const r = await fetch(`${BASE}/commands/next?session_id=${sessionId}`);
  if (!r.ok) return null;
  const t = await r.text();
  return t ? JSON.parse(t) as { command: "TURN_RIGHT"|"TURN_LEFT"|"LIGHT" } : null;
}
```

<a id="app-src-asr.ts"></a>
### 12. `app/src/asr.ts`
- Size: 820 bytes | LOC: 27 | SLOC: 22 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: 347ae9fd92e6

#### Brief
export type OnText = (finalText: string, isFinal: boolean) => void;

#### Auto Summary
export type OnText = (finalText: string, isFinal: boolean) => void;

#### Content

```typescript
export type OnText = (finalText: string, isFinal: boolean) => void;

export function createASR(lang = "en-US") {
  // @ts-expect-error webkit prefix for Chrome
  const SR = (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition;
  if (!SR) return { supported: false, start: () => {}, stop: () => {} };

  const rec = new SR();
  rec.lang = lang;
  rec.continuous = true;
  rec.interimResults = true;

  let onText: OnText | null = null;
  rec.onresult = (e: SpeechRecognitionEvent) => {
    if (!onText) return;
    for (let i = e.resultIndex; i < e.results.length; i++) {
      const r = e.results[i];
      onText(r[0].transcript.trim(), r.isFinal);
    }
  };

  return {
    supported: true,
    start(cb: OnText) { onText = cb; rec.start(); },
    stop() { rec.stop(); onText = null; }
  };
}
```

<a id="app-src-audio-CharacterSound.ts"></a>
### 13. `app/src/audio/CharacterSound.ts`
- Size: 437 bytes | LOC: 19 | SLOC: 15 | TODOs: 0 | Modified: 2025-10-14 17:22:31 | SHA1: ad31451dc9a7

#### Brief
app/src/audio/CharacterSound.ts

#### Auto Summary
// app/src/audio/CharacterSound.ts

#### Content

```typescript
// app/src/audio/CharacterSound.ts
import Phaser from "phaser";

export class CharacterSound {
  constructor(private scene: Phaser.Scene) {}

  playDeath(kind: "player" | "enemy" | "boss") {
    const key = {
      player: "se_player_die",
      enemy: "se_enemy_die",
      boss: "se_boss_die",
    }[kind];
    this.scene.sound.play(key, { volume: 0.8 });
  }

  playHit() {
    this.scene.sound.play("se_hit", { volume: 0.6 });
  }
}
```

<a id="app-src-audio-EffectSound.ts"></a>
### 14. `app/src/audio/EffectSound.ts`
- Size: 401 bytes | LOC: 18 | SLOC: 13 | TODOs: 0 | Modified: 2025-10-14 17:22:37 | SHA1: 29677fde1a83

#### Brief
app/src/audio/EffectSound.ts

#### Auto Summary
// app/src/audio/EffectSound.ts

#### Content

```typescript
// app/src/audio/EffectSound.ts
import Phaser from "phaser";

export class EffectSound {
  constructor(private scene: Phaser.Scene) {}

  bulletCollision() {
    this.scene.sound.play("se_bullet_collision", { volume: 0.6 });
  }

  bulletTimeout() {
    this.scene.sound.play("se_bullet_timeout", { volume: 0.5 });
  }

  uiSelect() {
    this.scene.sound.play("se_ui_select", { volume: 0.5 });
  }
}
```

<a id="app-src-audio-SoundManager.ts"></a>
### 15. `app/src/audio/SoundManager.ts`
- Size: 660 bytes | LOC: 24 | SLOC: 19 | TODOs: 0 | Modified: 2025-10-14 17:21:51 | SHA1: 8bd03df3d76d

#### Brief
app/src/audio/SoundManager.ts

#### Auto Summary
// app/src/audio/SoundManager.ts

#### Content

```typescript
// app/src/audio/SoundManager.ts
import Phaser from "phaser";
import { CharacterSound } from "./CharacterSound";
import { EffectSound } from "./EffectSound";

export class SoundManager {
  private static _inst: SoundManager;
  private scene!: Phaser.Scene;
  public characters!: CharacterSound;
  public effects!: EffectSound;

  static init(scene: Phaser.Scene) {
    if (!this._inst) this._inst = new SoundManager(scene);
    return this._inst;
  }

  static get I() { return this._inst; }

  private constructor(scene: Phaser.Scene) {
    this.scene = scene;
    this.characters = new CharacterSound(scene);
    this.effects = new EffectSound(scene);
  }
}
```

<a id="app-src-counter.ts"></a>
### 16. `app/src/counter.ts`
- Size: 274 bytes | LOC: 9 | SLOC: 9 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: 5133075ae32c

#### Brief
export function setupCounter(element: HTMLButtonElement) {
  let counter = 0

#### Auto Summary
export function setupCounter(element: HTMLButtonElement) {

#### Content

```typescript
export function setupCounter(element: HTMLButtonElement) {
  let counter = 0
  const setCounter = (count: number) => {
    counter = count
    element.innerHTML = `count is ${counter}`
  }
  element.addEventListener('click', () => setCounter(counter + 1))
  setCounter(0)
}
```

<a id="app-src-effects-DeathFX.ts"></a>
### 17. `app/src/effects/DeathFX.ts`
- Size: 2727 bytes | LOC: 82 | SLOC: 63 | TODOs: 0 | Modified: 2025-10-14 17:25:33 | SHA1: f5aa2b33345b

#### Brief
app/src/effects/DeathFX.ts

#### Auto Summary
// app/src/effects/DeathFX.ts

#### Content

```typescript
// app/src/effects/DeathFX.ts
import Phaser from "phaser";

type DeathKind = "player" | "enemy" | "boss" | "bullet_timeout" | "bullet_collision";


export class DeathFX {
  /** 種類別の推奨SEキー */
  static seKey(kind: DeathKind): string {
    switch (kind) {
        case "player": return "se_player_die";
        case "boss":   return "se_boss_die";
        case "enemy":  return "se_enemy_die";
        case "bullet_timeout": return "se_bullet_timeout";
        case "bullet_collision": return "se_bullet_collision";
    }
  }

    static playSE(scene: Phaser.Scene, key: string, detune = 0, volume = 0.8) {
    const exists = scene.cache.audio.exists(key);
    if (!exists) {
        console.warn(`[SE] Missing audio key: ${key}`);
        return;
    }

    scene.sound.play(key, { detune, volume });
    }

  /** 粒子エミッタ（bullet.png を使う） */
  static burstParticles(scene: Phaser.Scene, x: number, y: number, tint?: number) {
    const p = scene.add.particles(0, 0, "bullet", {
      x, y,
      speed: { min: 80, max: 260 },
      angle: { min: 0, max: 360 },
      lifespan: 420,
      scale: { start: 0.6, end: 0 },
      quantity: 26,
      tint,
      blendMode: "ADD",
    });
    scene.time.delayedCall(480, () => p.destroy());
  }

  /** 本体のフェード＆回転＆拡大 */
  static tweenVanish(scene: Phaser.Scene, go: Phaser.GameObjects.Sprite, onComplete?: () => void) {
    scene.tweens.add({
      targets: go,
      duration: 380,
      rotation: go.rotation + Phaser.Math.DegToRad(65),
      scale: go.scale * 1.35,
      alpha: 0,
      ease: "cubic.in",
      onComplete: () => onComplete && onComplete(),
    });
  }

  /** 白フラッシュ（短い） */
  static flash(scene: Phaser.Scene, go: Phaser.GameObjects.Sprite) {
    go.setTintFill(0xffffff);
    scene.time.delayedCall(60, () => go.clearTint());
  }

  /** 入口：死亡演出＋SE。完了後に destroy() まで面倒を見る */
  static play(scene: Phaser.Scene, sprite: Phaser.GameObjects.Sprite & { destroy: () => void }, kind: DeathKind) {
    // 1) フラッシュ
    this.flash(scene, sprite);

    // 2) SE
    this.playSE(scene, this.seKey(kind), kind === "boss" ? -200 : 0, kind === "player" ? 0.9 : 0.7);

    // 3) 粒子（色味を種類で少し変える）
    const tint = kind === "player" ? 0x80d0ff : kind === "boss" ? 0xff8080 : 0xffe080;
    this.burstParticles(scene, sprite.x, sprite.y, tint);

    // 4) カメラちょい揺れ（ボスは強め）
    const cam = scene.cameras.main;
    cam.shake(kind === "boss" ? 200 : 120, kind === "boss" ? 0.01 : 0.006);

    // 5) 本体トゥイーン → 破棄
    this.tweenVanish(scene, sprite, () => sprite.destroy());
  }
}
```

<a id="app-src-entities-Base.ts"></a>
### 18. `app/src/entities/Base.ts`
- Size: 4203 bytes | LOC: 145 | SLOC: 118 | TODOs: 0 | Modified: 2025-10-14 17:06:57 | SHA1: d6314956d7ba

#### Brief
import Phaser from "phaser";
import { DeathFX } from "../effects/DeathFX";

#### Auto Summary
import Phaser from "phaser";

#### Content

```typescript
import Phaser from "phaser";
import { DeathFX } from "../effects/DeathFX";

export type BaseOptions = {
  scale?: number;
  immovable?: boolean;
  collideWorldBounds?: boolean;
  showLabel?: boolean;
  labelDepth?: number;
  drawHitbox?: boolean;
};

export class Base extends Phaser.Physics.Arcade.Sprite {
  static DEBUG_HITBOXES = true;
  protected maxHp = 1;
  protected hp = 1;
  protected nameTag?: Phaser.GameObjects.Text;
  protected hitboxGfx?: Phaser.GameObjects.Graphics;
  protected opts: Required<BaseOptions>;

  constructor(
    scene: Phaser.Scene,
    x: number,
    y: number,
    texture: string,
    frame: number | string = 0,
    public displayName: string = "",
    maxHp = 1,
    options: BaseOptions = {}
  ) {
    super(scene, x, y, texture, frame);

    this.opts = {
      scale: options.scale ?? 1,
      immovable: options.immovable ?? false,
      collideWorldBounds: options.collideWorldBounds ?? false,
      showLabel: options.showLabel ?? true,
      labelDepth: options.labelDepth ?? 100,
      drawHitbox: options.drawHitbox ?? true,
    };

    this.maxHp = maxHp;
    this.hp = maxHp;

    scene.add.existing(this);
    scene.physics.add.existing(this);

    this.setOrigin(0.5, 0.5);
    if (this.opts.scale !== 1) this.setScale(this.opts.scale);

    const body = this.body as Phaser.Physics.Arcade.Body;
    body.setImmovable(this.opts.immovable);
    this.setCollideWorldBounds(this.opts.collideWorldBounds);

    this.syncHitboxToDisplay();

    if (this.opts.showLabel && this.displayName) {
      this.nameTag = scene.add.text(this.x, this.y, this.displayName, {
        font: "14px monospace",
        color: "#fff",
        stroke: "#000",
        strokeThickness: 3,
      })
      .setOrigin(0.5, 1)
      .setDepth(this.opts.labelDepth);
    }

    this.hitboxGfx = scene.add.graphics().setDepth(10000);
  }

  protected syncHitboxToDisplay() {
    const body = this.body as Phaser.Physics.Arcade.Body;
    const w = Math.max(1, Math.round(this.displayWidth));
    const h = Math.max(1, Math.round(this.displayHeight));
    body.setSize(w, h, true);
  }

  public isArmed(): boolean {
    return false;
  }

  setScale(x: number, y?: number): this {
    super.setScale(x, y);
    if (this.body) this.syncHitboxToDisplay();
    return this;
  }

  setFrame(frame: string | number): this {
    super.setFrame(frame);
    if (this.body) this.syncHitboxToDisplay();
    return this;
  }

  public setHitboxSize(width: number, height: number) {
    const body = this.body as Phaser.Physics.Arcade.Body;
    body.setSize(Math.max(1, Math.round(width)), Math.max(1, Math.round(height)), true);
  }

  /** HPを減算し、0以下なら死ぬ */
  public takeDamage(n = 1) {
    this.hp = Math.max(0, this.hp - n);
    if (this.hp <= 0) this.die();
  }

  /** 外部からも死亡判定を参照可能に */
  public isDead(): boolean {
    return this.hp <= 0 || !this.active;
  }

  /** デフォルトの死亡挙動 */
  protected die() {
    this.nameTag?.destroy();
    this.hitboxGfx?.destroy();

    // ★ 種類判定（デフォルト enemy）
    const kind = (this.getData("kind") as "player"|"enemy"|"boss") ?? "enemy";
    // ★ 演出＆音 → 完了後 destroy（DeathFX 側で破棄）
    DeathFX.play(this.scene, this as unknown as Phaser.GameObjects.Sprite, kind);
    // active を落として多重呼び出しを防止
    this.setActive(false).setVisible(false);
    // 以降の update では処理させない
    (this.body as Phaser.Physics.Arcade.Body).enable = false;
    this.destroy();
  }

  /** 1フレームごとにHP=0の個体を整理 */
  preUpdate(time: number, delta: number) {
    super.preUpdate(time, delta);
    if (this.hp <= 0 && this.active) {
      this.die();
      return;
    }

    if (this.nameTag && this.active) {
      this.nameTag.setPosition(this.x, this.y - this.displayHeight * 0.5 - 8);
    }

    if (this.hitboxGfx && Base.DEBUG_HITBOXES && this.opts.drawHitbox) {
      const body = this.body as Phaser.Physics.Arcade.Body;
      this.hitboxGfx.clear();
      this.hitboxGfx.lineStyle(1, 0x00ff00, 0.9);
      this.hitboxGfx.strokeRect(body.x, body.y, body.width, body.height);
    }
  }
}
```

<a id="app-src-entities-Boss.ts"></a>
### 19. `app/src/entities/Boss.ts`
- Size: 364 bytes | LOC: 12 | SLOC: 11 | TODOs: 0 | Modified: 2025-10-14 17:03:02 | SHA1: c4d2764c1aa9

#### Brief
import Phaser from "phaser";
import { CharacterBase } from "./CharacterBase";

#### Auto Summary
import Phaser from "phaser";

#### Content

```typescript
import Phaser from "phaser";
import { CharacterBase } from "./CharacterBase";

export class Boss extends CharacterBase {
  constructor(scene: Phaser.Scene, x: number, y: number, name: string, maxHp = 30) {
    super(scene, x, y, "boss", 0, name, maxHp, {
      sounds: { death: "se_boss_die" },
    });
    this.setData("kind", "boss");
    this.setScale(2);
  }
}
```

<a id="app-src-entities-Bullet.ts"></a>
### 20. `app/src/entities/Bullet.ts`
- Size: 2552 bytes | LOC: 84 | SLOC: 70 | TODOs: 0 | Modified: 2025-10-14 17:27:45 | SHA1: eef1722073b3

#### Brief
app/src/entities/Bullet.ts

#### Auto Summary
// app/src/entities/Bullet.ts

#### Content

```typescript
// app/src/entities/Bullet.ts
import Phaser from "phaser";
import { Base } from "./Base";
import { logger } from "../logger";
import { SoundManager } from "../audio/SoundManager";

export interface BulletOptions {
  speed: number;
  lifespanMs: number;
  radius: number;
  armDelayMs: number;   // ← 追加：時限信管（アーム遅延）
}

export class Bullet extends Base {
  private speed = 500;
  private lifespanMs = 3000;
  private armDelayMs = 1300;
  private bornAt = 0;

  constructor(
    scene: Phaser.Scene,
    x: number,
    y: number,
    textureKey: string = "bullet",
    frame?: number | null
  ) {
    super(scene, x, y, textureKey, frame ?? 0, "", 1, {
      immovable: true,
      collideWorldBounds: false,
      showLabel: false,
      labelDepth: 0,
    });

    this.bornAt = scene.time.now;

    // 画面外で自壊
    this.scene.physics.world.on("worldbounds", (b: Phaser.Physics.Arcade.Body) => {
      if (b.gameObject === this) this.die();
    });

    this.setDepth(10);
  }

  /** 後からオプションを一括設定（チェーン可） */
  configure(opts: Partial<BulletOptions>) {
    if (opts.speed       !== undefined) this.speed       = opts.speed;
    if (opts.lifespanMs  !== undefined) this.lifespanMs  = opts.lifespanMs;
    if (opts.armDelayMs  !== undefined) this.armDelayMs  = opts.armDelayMs;
    if (opts.radius      !== undefined) {
      const d = Math.max(1, Math.round(opts.radius * 2));
      this.setDisplaySize(d, d);
    }
    return this;
  }

  /** 武装（アーム）済みか？ */
  public isArmed(): boolean {
    let b = (this.scene.time.now - this.bornAt) >= this.armDelayMs;
    logger.cmd(`this.scene.time.now ${this.scene.time.now}`);
    logger.cmd(`this.bornAt ${this.bornAt}`);
    logger.cmd(`this.armDelayMs ${this.armDelayMs}`);
    logger.cmd(`this.scene.time.now - this.bornAt ${this.scene.time.now - this.bornAt}`);
    return b;
  }

  /** 発射（角度は度数法） */
  fire(angleDeg: number, speed = this.speed) {
    this.bornAt = this.scene.time.now;
    const body = this.body as Phaser.Physics.Arcade.Body;
    this.scene.physics.velocityFromAngle(angleDeg, speed, body.velocity);
    this.setAngle(angleDeg);
  }

  preUpdate(time: number, delta: number) {
    super.preUpdate(time, delta);
    SoundManager.I.effects.bulletTimeout();
    // 寿命で自然消滅
    if (time - this.bornAt >= this.lifespanMs) {
      // 通常の死亡処理の前に種別を上書き
      this.setData("kind", "bullet_timeout");
      this.die();
    }
  }
}
```

<a id="app-src-entities-CharacterBase.ts"></a>
### 21. `app/src/entities/CharacterBase.ts`
- Size: 2229 bytes | LOC: 62 | SLOC: 50 | TODOs: 0 | Modified: 2025-10-14 17:23:41 | SHA1: 0163ba64c949

#### Brief
app/src/entities/CharacterBase.ts

#### Auto Summary
// app/src/entities/CharacterBase.ts

#### Content

```typescript
// app/src/entities/CharacterBase.ts
import Phaser from "phaser";
import { Base } from "./Base";
import { DeathFX } from "../effects/DeathFX";
import { SoundManager } from "../audio/SoundManager";

export type CharacterSoundProfile = {
  death?: string;   // 撃破（死亡）時のSEキー
  hit?: string;     // 被弾時のSEキー（必要なら）
  attack?: string;  // 攻撃時のSEキー（必要なら）
};

export type CharacterBaseOptions = ConstructorParameters<typeof Base>[6] & {
  sounds?: CharacterSoundProfile;
};

export class CharacterBase extends Base {
  protected sounds: Required<CharacterSoundProfile> = {
    death: "", hit: "", attack: "",
  };

  constructor(
    scene: Phaser.Scene,
    x: number,
    y: number,
    texture: string,
    frame: number | string,
    displayName: string,
    maxHp = 1,
    opts: CharacterBaseOptions = {}
  ) {
    super(scene, x, y, texture, frame, displayName, maxHp, opts);
    if (opts?.sounds) {
      this.sounds = { ...this.sounds, ...opts.sounds };
    }
  }

  /** ここで死亡演出＋死亡SEをまとめる（個別SEがあれば優先） */
  protected override die() {
    this.nameTag?.destroy();
    this.hitboxGfx?.destroy();

    const kind = (this.getData("kind") as "player"|"enemy"|"boss") ?? "enemy";

    // 個別SEが指定されていればそれを使う。なければ種類ごとのデフォルトにフォールバック
    const seKey = this.sounds.death && this.sounds.death.length > 0
      ? this.sounds.death
      : DeathFX.seKey(kind);

    // 視覚演出は共通、SEは上のキーで再生
    // DeathFX.playSE(this.scene, seKey, kind === "boss" ? -200 : 0, kind === "player" ? 0.9 : 0.7);
    SoundManager.I.characters.playDeath(kind);
    DeathFX.burstParticles(this.scene, this.x, this.y, kind === "player" ? 0x80d0ff : kind === "boss" ? 0xff8080 : 0xffe080);
    const cam = this.scene.cameras.main;
    cam.shake(kind === "boss" ? 200 : 120, kind === "boss" ? 0.01 : 0.006);
    DeathFX.tweenVanish(this.scene, this as unknown as Phaser.GameObjects.Sprite, () => {
      this.setActive(false).setVisible(false);
      (this.body as Phaser.Physics.Arcade.Body).enable = false;
      this.destroy();
    });
  }
}
```

<a id="app-src-entities-Enemy.ts"></a>
### 22. `app/src/entities/Enemy.ts`
- Size: 330 bytes | LOC: 11 | SLOC: 10 | TODOs: 0 | Modified: 2025-10-14 17:02:52 | SHA1: 1f2c6f66f6c2

#### Brief
import Phaser from "phaser";
import { CharacterBase } from "./CharacterBase";

#### Auto Summary
import Phaser from "phaser";

#### Content

```typescript
import Phaser from "phaser";
import { CharacterBase } from "./CharacterBase";

export class Enemy extends CharacterBase {
  constructor(scene: Phaser.Scene, x: number, y: number, name: string) {
    super(scene, x, y, "enemy", 0, name, 1, {
      sounds: { death: "se_enemy_die" },
    });
    this.setData("kind", "enemy");
  }
}
```

<a id="app-src-entities-Player.ts"></a>
### 23. `app/src/entities/Player.ts`
- Size: 383 bytes | LOC: 13 | SLOC: 11 | TODOs: 0 | Modified: 2025-10-14 17:02:44 | SHA1: e112c5f03141

#### Brief
import Phaser from "phaser";
import { CharacterBase } from "./CharacterBase";

#### Auto Summary
import Phaser from "phaser";

#### Content

```typescript
import Phaser from "phaser";
import { CharacterBase } from "./CharacterBase";

export class Player extends CharacterBase {
  public direction: number = 90;

  constructor(scene: Phaser.Scene, x: number, y: number, name = "you", maxHp = 5) {
    super(scene, x, y, "player", 0, name, maxHp, {
      sounds: { death: "se_player_die" },
    });
    this.setData("kind", "player");
  }
}
```

<a id="app-src-entities-Rock.ts"></a>
### 24. `app/src/entities/Rock.ts`
- Size: 558 bytes | LOC: 18 | SLOC: 15 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: ea5837dc0939

#### Brief
import Phaser from "phaser";

#### Auto Summary
import Phaser from "phaser";

#### Content

```typescript
import Phaser from "phaser";

export class Rock extends Phaser.GameObjects.Rectangle {
  nameTag: Phaser.GameObjects.Text;

  constructor(scene: Phaser.Scene, x: number, y: number, w: number, h: number, name: string) {
    super(scene, x, y, w, h, 0x5b4b3a);
    scene.add.existing(this);
    scene.physics.add.existing(this, true); // static body
    this.setStrokeStyle(2, 0x2b241d, 0.6);
    this.setData("name", name);

    this.nameTag = scene.add.text(x - w / 2, y - h / 2 - 14, name, {
      font: "14px monospace",
      color: "#fff",
    });
  }
}
```

<a id="app-src-logger.ts"></a>
### 25. `app/src/logger.ts`
- Size: 3278 bytes | LOC: 82 | SLOC: 69 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: ae54cbeb9487

#### Brief
export type LogLevel = "log" | "info" | "warn" | "error" | "cmd";
type Entry = { ts: number; level: LogLevel; msg: string };

#### Auto Summary
export type LogLevel = "log" | "info" | "warn" | "error" | "cmd";

#### Content

```typescript
export type LogLevel = "log" | "info" | "warn" | "error" | "cmd";
type Entry = { ts: number; level: LogLevel; msg: string };

export class OverlayLogger {
  private el: HTMLElement;
  private buf: Entry[] = [];
  private max = 200;
  private visible = true;

  constructor(opts?: { max?: number; captureConsole?: boolean }) {
    if (opts?.max) this.max = opts.max;
    this.el = this.ensureOverlay();
    if (opts?.captureConsole) this.captureConsole();
    window.addEventListener("keydown", (e) => {
      if (e.key === "`") this.toggle();
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "l") {
        e.preventDefault(); this.clear();
      }
    });
  }
  private ensureOverlay() {
    const el = document.getElementById("log") as HTMLPreElement | null;
    if (!el) throw new Error("#log element not found");
    return el;
  }
  
  private captureConsole() {
    const _log = console.log, _info = console.info, _warn = console.warn, _error = console.error;
    console.log = (...a: any[]) => { this.write("log", a.join(" ")); _log(...a); };
    console.info = (...a: any[]) => { this.write("info", a.join(" ")); _info(...a); };
    console.warn = (...a: any[]) => { this.write("warn", a.join(" ")); _warn(...a); };
    console.error = (...a: any[]) => { this.write("error", a.join(" ")); _error(...a); };
  }


  /** ユーザー向け API */
  log(msg: string)  { this.write("log", msg); }
  info(msg: string) { this.write("info", msg); }
  warn(msg: string) { this.write("warn", msg); }
  error(msg: string){ this.write("error", msg); }
  cmd(msg: string)  { this.write("cmd", msg); }

  clear() { this.buf = []; this.render(); }
  toggle() { this.visible = !this.visible; (this.el as any).style.display = this.visible ? "" : "none"; }

  /** コア：バッファ追加 → 上限超過ぶんを破棄 → 逆順で描画（最新が最上段） */
  private write(level: LogLevel, msg: string) {
    this.buf.push({ ts: Date.now(), level, msg });
    if (this.buf.length > this.max) {
      // 先頭（＝最も古い）から削る
      this.buf.splice(0, this.buf.length - this.max);
    }
    this.render();
  }

  private render() {
    // 最新→古い の順に並べて上から描画
    const lines = this.buf
      .slice()            // コピー
      .reverse()          // 逆順（最新が先頭）
      .map(e => this.format(e));
    (this.el as HTMLPreElement).textContent = lines.join("\n");
  }

  private format(e: Entry) {
    // ここは好みで。レベルの装飾など（例： [INFO] など）
    switch (e.level) {
      case "info":  return `[INFO]  ${e.msg}`;
      case "warn":  return `[WARN]  ${e.msg}`;
      case "error": return `[ERROR] ${e.msg}`;
      case "cmd":   return `> ${e.msg}`;
      default:      return e.msg;
    }
  }

  private hhmmss(ts:number){ const d=new Date(ts);
    return `${String(d.getHours()).padStart(2,"0")}:${String(d.getMinutes()).padStart(2,"0")}:${String(d.getSeconds()).padStart(2,"0")}`; }
  private tag(level: LogLevel){
    switch(level){ case "cmd": return "[CMD]"; case "info": return "[INFO]"; case "warn": return "[WARN]"; case "error": return "[ERR ]"; default: return "[LOG ]"; }
  }
}
export const logger = new OverlayLogger({ max: 300, captureConsole: false });
```

<a id="app-src-main.ts"></a>
### 26. `app/src/main.ts`
- Size: 436 bytes | LOC: 17 | SLOC: 13 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: 5d07c0d688b8

#### Brief
import Phaser from "phaser";
import { TitleScene } from "./scenes/TitleScene";

#### Auto Summary
import Phaser from "phaser";

#### Content

```typescript
import Phaser from "phaser";
import { TitleScene } from "./scenes/TitleScene";
import { MainScene } from "./scenes/MainScene";
import { logger } from "./logger";

logger.info("Booting Phaser...");

const config: Phaser.Types.Core.GameConfig = {
  parent: "game-root",
  scene: [TitleScene, MainScene],
  backgroundColor: "#20242a",
  physics: { default: "arcade", arcade: { } },
};

new Phaser.Game(config);

logger.cmd("Initialized");
```

<a id="app-src-scenes-MainScene.ts"></a>
### 27. `app/src/scenes/MainScene.ts`
- Size: 21961 bytes | LOC: 543 | SLOC: 392 | TODOs: 0 | Modified: 2025-10-14 17:27:01 | SHA1: 1130fc70a8e6

#### Brief
import Phaser from "phaser";
import { createASR } from "../asr";

#### Auto Summary
import Phaser from "phaser";

#### Content

```typescript
import Phaser from "phaser";
import { createASR } from "../asr";
import { logger } from "../logger";
import { Rock } from "../entities/Rock";
import { Enemy } from "../entities/Enemy";
import { Boss } from "../entities/Boss";
import { Player } from "../entities/Player";
import { Bullet } from '../entities/Bullet';
import { DeathFX } from "../effects/DeathFX";
import { SoundManager } from "../audio/SoundManager";

export class MainScene extends Phaser.Scene {
  private player!: Player;
  private bullets!: Phaser.Physics.Arcade.Group; 
  private cursors!: Phaser.Types.Input.Keyboard.CursorKeys;
  private friendlies!: Phaser.Physics.Arcade.Group;
  private enemies!:    Phaser.Physics.Arcade.Group;
  private rocks!:      Phaser.Physics.Arcade.StaticGroup;
  private boss!: Boss; // ←型をBossに
  // 既存のフィールド群の近くに追加
  private navTargetRock: Phaser.GameObjects.Rectangle | null = null;

  private words_rock = [
    "rock","stone","hill","cliff","sand","dust","mud","cave","valley","island",
    "shore","beach","wave","shell","pebble","boulder","mountain","forest","tree","leaf",
    "root","branch","grass","moss","vine","river","stream","lake","pond","water",
    "ice","snow","frost","storm","cloud","wind","breeze","rain","drop","mist",
    "shadow","light","sun","moon","star","sky","dawn","night","day","twilight",
    "earth","soil","field","plain","plate","ridge","path","trail","step","road",
    "wall","gate","bridge","pillar","arch","ring","circle","cube","crystal","gem",
    "iron","silver","gold","metal","ore","coal","salt","clay","brick","dusty",
    "silent","still","calm","cold","hard","solid","heavy","quiet","deep","rough",
    "wild","lonely","ancient","broken","gray","brown","smooth","soft","sharp","flat"
    ]
  private words_enemy = [
    "fire","flame","smoke","ash","ember","fang","claw","wing","scale","tail",
    "wolf","bear","fox","hawk","snake","rat","crow","bat","boar","owl",
    "ghost","spirit","shade","shadow","demon","devil","beast","ogre","goblin","witch",
    "wizard","soldier","hunter","bandit","pirate","ninja","robot","drone","guard","sniper",
    "viper","wasp","bee","ant","spider","scorpion","hound","lion","tiger","dragon",
    "rage","anger","hate","fear","pain","death","skull","bone","blood","fangs",
    "sword","blade","arrow","gun","bomb","laser","missile","tank","snare","trap",
    "storm","thunder","lightning","spark","blast","toxic","acid","venom","dark","evil",
    "hot","mad","wild","fast","swift","fierce","cruel","sharp","dead","furious",
    "iron","steel","mech","void","warp","curse","doom","burn","bite","crash"
    ]

  wasd!: { [k: string]: Phaser.Input.Keyboard.Key };
  facing: "back" | "left" | "right" | "forward" = "back";

  // === スプライトシート設定 ===
  // 1コマのサイズ（あなたの素材に合わせて調整）
  static FRAME_W = 32;
  static FRAME_H = 32;

  // フレーム割り当て（例：4x4 = 16コマ）
  // 0-3: 下、4-7: 左、8-11: 右、12-15: 上 という並びを想定
  static FRAMES = {
    back:  { idle: 0,  walk: [0, 1, 2] },
    left:  { idle: 3,  walk: [3, 4, 5] },
    right: { idle: 6,  walk: [6, 7, 8] },
    forward:    { idle: 9, walk: [9, 10, 11] },
  };

  // input
  private dir = { forward:false, back:false, left:false, right:false };
  private shootCooldown = 140;
  private lastShot = 0;
  private  W = 1200;
  private  H = 900;
  private  Max_H = 4800;

  constructor(){
    super("MainScene");
  }

  preload() {
    this.load.spritesheet('player', 'images/witch_sheet.png', {frameWidth: MainScene.FRAME_W,frameHeight: MainScene.FRAME_H,},);
    this.load.spritesheet('enemy', 'images/enemy_sheet.png', {frameWidth: MainScene.FRAME_W,frameHeight: MainScene.FRAME_H,},);
    this.load.spritesheet('boss', 'images/enemy_sheet.png', {frameWidth: MainScene.FRAME_W,frameHeight: MainScene.FRAME_H,});
    this.load.image("bullet", "images/bullet.png");
    this.load.audio("bgm_main", "audio/bgm.mp3");
    this.load.audio("se_player_die", "audio/character_destroy.mp3");
    this.load.audio("se_enemy_die",  "audio/character_destroy.mp3");
    this.load.audio("se_boss_die",   "audio/character_destroy.mp3");
    this.load.audio("se_bullet_timeout", "audio/bullet_timeout.mp3");
    this.load.audio("se_bullet_collision", "audio/bullet_timeout.mp3");
  }

  create() {
    // log
    logger.cmd("GAME START");
    SoundManager.init(this);
    // audio
    const bgm = this.sound.add("bgm_main", { loop: true, volume: 0.4 });
    bgm.play();

    // ground
    this.cameras.main.setBackgroundColor(0x66CDAA);
    this.add.rectangle(this.W/2, this.H/2, this.W, this.H, 0x66CDAA);

    this.land = this.physics.add.staticGroup();

    // boundary & camera
    this.cameras.main.setBounds(0, 0, this.W, this.Max_H);
    this.physics.world.setBounds(0, 0, this.W, this.Max_H);

    // 弾グループ


    // ★ 弾同士の衝突で相殺（コールバックは1回登録でOK）


    // 例：プレイヤー発射処理（角度はプレイヤー向きから）
    
    // Player
    this.friendlies = this.physics.add.group({ classType: Player, runChildUpdate: true });
    this.player = new Player(this, this.W/2, this.Max_H - this.H/2, "you", 5);
    this.friendlies.add(this.player);

    this.cursors = this.input.keyboard!.createCursorKeys();
    this.wasd = {
      W: this.input.keyboard!.addKey(Phaser.Input.Keyboard.KeyCodes.W),
      A: this.input.keyboard!.addKey(Phaser.Input.Keyboard.KeyCodes.A),
      S: this.input.keyboard!.addKey(Phaser.Input.Keyboard.KeyCodes.S),
      D: this.input.keyboard!.addKey(Phaser.Input.Keyboard.KeyCodes.D),
      SPACE: this.input.keyboard!.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE),
    } as any;

    // （任意）アニメ登録：右・左・上・下など
    this.anims.create({
      key: 'idle-right',
      frames: [{ key: 'player', frame: 0 }],
      frameRate: 1, repeat: -1,
    });
    this.player.play('idle-right');

    // bullets group
    this.bullets = this.physics.add.group({
      classType: Bullet,
      runChildUpdate: true,
      maxSize: 600,
    });

    // animation
    this.makeWalkAnim("walk-back",    MainScene.FRAMES.back.walk);
    this.makeWalkAnim("walk-left",    MainScene.FRAMES.left.walk);
    this.makeWalkAnim("walk-right",   MainScene.FRAMES.right.walk);
    this.makeWalkAnim("walk-forward", MainScene.FRAMES.forward.walk);
  
    // 発射（スペース）
    this.input.keyboard!.on('keydown-SPACE', () => {
      this.shoot(); 
    });

    
    this.cameras.main.startFollow(this.player, true, 0.1, 0.1);

    // 入力（WASD/矢印 = 移動、H/J/K/L = 左/下/上/右に射撃）
    const kb = this.input.keyboard!;
    const setKey = (key:string, k:keyof typeof this.dir, v:boolean)=>{
      kb.on(`${v?'keydown':'keyup'}-${key}`, ()=> this.dir[k]=v);
    };
    const logKey = (type:string, key:string)=> logger.cmd(`key ${type}: ${key}`);
    kb.on("keydown", (e: KeyboardEvent) => logKey("back", e.key));
    kb.on("keyup",   (e: KeyboardEvent) => logKey("forward",   e.key));

    ["W:up","S:down","A:left","D:right","forward:up","DOWN:down","LEFT:left","RIGHT:right"]
      .forEach(s=>{ const [k,n]=s.split(":") as [string, any]; setKey(k, n, true); setKey(k, n, false); });

    // Mic
    this.setupMic();

    // Enemy
    this.enemies = this.physics.add.group({ classType: Enemy, runChildUpdate: true });

    // Random Position
    const ENEMY_COUNT = 6;
    for (let i = 0; i < ENEMY_COUNT; i++) {
      const randX = Phaser.Math.Between(100, this.W - 100);
      const randY = Phaser.Math.Between(500, this.Max_H - 200);
      const e = new Enemy(this, randX, randY, this.getUniqueWord(this.words_enemy));
      this.enemies.add(e);
    }

    // === 敵弾 ===
    // === 視界チェック付き：敵の定期射撃 ===
    this.time.addEvent({
      delay: 2000, // 判定は0.3秒ごと（軽量化しつつ反応は良く）
      loop: true,
      callback: () => {
        if (!this.player?.active) return;

        this.enemies.children.each((enemyGO: Phaser.GameObjects.GameObject) => {
          const e = enemyGO as Phaser.Physics.Arcade.Sprite;
          if (!e.active) return;

          // 視程・視野角・遮蔽の3条件
          const canSee =
            this.inFOVAndRange(e.x, e.y, this.player.x, this.player.y, { fovDeg: 120, range: 700 }) &&
            this.hasLineOfSight(e.x, e.y, this.player.x, this.player.y);

          if (!canSee) return;

          // 撃つ
          const ang = Phaser.Math.RadToDeg(Phaser.Math.Angle.Between(e.x, e.y, this.player.x, this.player.y));
          this.spawnBullet(e.x, e.y, ang, 220, 8, 2000, 300);
        });
      },
    });

    // === ランダム岩（障害物） ===
    this.rocks = this.physics.add.staticGroup();

    const ROCK_COUNT = 24; // 岩の数
    const MIN_W = 24, MAX_W = 96; // 幅の最小・最大
    const MIN_H = 24, MAX_HH = 96; // 高さの最小・最大
    const SAFE_RADIUS = 140; // プレイヤー初期位置の安全距離

    const playerSpawn = new Phaser.Math.Vector2(this.player.x, this.player.y);
    const placed: Phaser.Geom.Rectangle[] = []; // 重なり回避用

    const placeRock = (rx: number, ry: number, rw: number, rh: number) => {

      const name = this.getUniqueWord(this.words_rock);
      const rock = new Rock(this, rx, ry, rw, rh, name);
      this.rocks.add(rock);

      placed.push(new Phaser.Geom.Rectangle(rx - rw / 2, ry - rh / 2, rw, rh));
    };
    // ランダム配置ループ
    for (let i = 0; i < ROCK_COUNT; i++) {
      let tries = 0;
      while (tries++ < 25) {
        const rw = Phaser.Math.Between(MIN_W, MAX_W);
        const rh = Phaser.Math.Between(MIN_H, MAX_HH);
        const rx = Phaser.Math.Between(60 + rw/2, this.W - 60 - rw/2);
        const ry = Phaser.Math.Between(200 + rh/2, this.Max_H - 200 - rh/2);

        // プレイヤー初期位置の安全距離を確保
        if (playerSpawn.distance(new Phaser.Math.Vector2(rx, ry)) < SAFE_RADIUS) continue;

        // 既存の岩と簡易重なり回避
        const cand = new Phaser.Geom.Rectangle(rx - rw/2, ry - rh/2, rw, rh);
        const is_overlaps = placed.some(r => Phaser.Geom.Rectangle.Overlaps(r, cand));
        if (is_overlaps) continue;

        placeRock(rx, ry, rw, rh);

        break;
      }
    }

    // === Boss ===
    const bossName = this.getUniqueWord(this.words_enemy);
    this.boss = new Boss(this, this.W * 0.5, 300, bossName, 30);
    this.enemies.add(this.boss);

    // === Boss atack ===
    this.time.addEvent({
      delay: 1500,
      loop: true,
      callback: () => {
        if (!this.boss?.active) return;

      // visibility
      const canSee =
        this.inFOVAndRange(this.boss.x, this.boss.y, this.player.x, this.player.y, { fovDeg: 120, range: 700 }) &&
        this.hasLineOfSight(this.boss.x, this.boss.y, this.player.x, this.player.y);

      if (!canSee) return;

        // 複数弾を放つ（扇状）
        const numBullets = 6;
        const baseDeg = Phaser.Math.RadToDeg(Phaser.Math.Angle.Between(this.boss.x, this.boss.y, this.player.x, this.player.y));
        for (let i = 0; i < numBullets; i++) {
          const a = baseDeg - 30 + (60 * i) / 5; // -30°〜+30°を6発
          this.spawnBullet(this.boss.x, this.boss.y, a, 300, 8, 2500, 300);
        }
      },
    });

    // 衝突判定
    // 動的 × 静的
    this.physics.add.collider(this.friendlies,  this.rocks);   // プレイヤーは岩で止まる
    this.physics.add.collider(this.enemies, this.rocks);   // 敵も岩で止まる

    // 4) 弾 × 岩（現状維持：弾だけ消える＝岩は不死）
    this.physics.add.collider(this.bullets, this.rocks, (bGO) => {
      (bGO as Bullet).takeDamage(1);
    });

    // 5) 弾 × 弾
    this.physics.add.collider(this.bullets, this.bullets, (aGO, bGO) => {
      const a = aGO as Bullet, b = bGO as Bullet;
      if (!a.active || !b.active) return;
      // どちらかが未武装なら相殺しない
      if (!a.isArmed() && !b.isArmed()) return;

      // 死亡前に効果音（種類：bullet_collision）
      DeathFX.playSE(this, DeathFX.seKey("bullet_collision"), 0, 0.6);

      a.takeDamage(1);
      b.takeDamage(1);
    });

    // Enemy Collision
    this.physics.add.overlap(this.bullets, this.enemies, (bGO, eGO) => {
      const b = bGO as Bullet;
      if (!b.isArmed()) return;
      (eGO as any).takeDamage?.(1);
      logger.cmd(`Enemy Hit`)
      b.takeDamage(1);
    });

    // Player Collision
    this.physics.add.overlap(this.bullets, this.friendlies, (bGO, pGO) => {
      const b = bGO as Bullet;
      if (!b.isArmed()) return;
      (pGO as any).takeDamage?.(1);
      logger.cmd(`Player Hit`)
      b.takeDamage(1);
    });

  }

  update(time:number) {
    const speed = 200;

    // === tracking ===
    if (this.navTargetRock && this.navTargetRock.active) {
      const r = this.navTargetRock;
      const rect = new Phaser.Geom.Rectangle(r.x - r.width/2, r.y - r.height/2, r.width, r.height);

      // the nearlest rock
      const cx = Phaser.Math.Clamp(this.player.x, rect.left,  rect.right);
      const cy = Phaser.Math.Clamp(this.player.y, rect.top,   rect.bottom);
      const dist = Phaser.Math.Distance.Between(this.player.x, this.player.y, cx, cy);

      // ★ arrives nearly
      if (dist <= 6) { 
        this.onArrived(r);
      } else {
        // tracking movement
        this.physics.moveTo(this.player, cx, cy, 200);

        const vx = (this.player.body as Phaser.Physics.Arcade.Body).velocity.x;
        const vy = (this.player.body as Phaser.Physics.Arcade.Body).velocity.y;
        if (Math.abs(vx) > Math.abs(vy)) this.facing = vx > 0 ? "right" : "left";
        else                              this.facing = vy > 0 ? "back"  : "forward";
        this.player.play(`walk-${this.facing}`, true);

        return;
      }
    }

    const left    = (this.cursors.left?.isDown  || this.wasd.A.isDown   || this.dir.left);
    const right   = (this.cursors.right?.isDown || this.wasd.D.isDown   || this.dir.right);
    const forward = (this.cursors.up?.isDown    || this.wasd.W.isDown   || this.dir.forward);
    const back    = (this.cursors.down?.isDown  || this.wasd.S.isDown   || this.dir.back);

    // 速度初期化
    for (const friendly of this.friendlies.getChildren()) {
      friendly.setVelocity(0);
      // 入力に応じて速度・向き設定（斜めは最後に押された軸を優先したい場合は工夫可）
      let moving = false;
      if (left)    { friendly.setVelocityX(-speed); this.facing = "left";    moving = true; friendly.direction=180; }
      if (right)   { friendly.setVelocityX( speed); this.facing = "right";   moving = true; friendly.direction=0; }
      if (forward) { friendly.setVelocityY(-speed); this.facing = "forward"; moving = true; friendly.direction=270; }
      if (back)    { friendly.setVelocityY( speed); this.facing = "back";    moving = true; friendly.direction=90; }
      // アニメ再生 or 待機フレーム
      if (moving) {
        friendly.play(`walk-${this.facing}`, true);
      } else {
        // 立ち止まったらその向きのidleフレームで停止
        friendly.anims.stop();
        const idleFrame = MainScene.FRAMES[this.facing].idle;
        friendly.setFrame(idleFrame);
      }
    }

    // 連射（マイクで“shoot”連呼された場合の簡易クールダウン）
    if (time - this.lastShot < this.shootCooldown) return;
  }

  // ==== ユーティリティ: 歩行アニメを作る ====
  private makeWalkAnim(key: string, frames: number[]) {
    this.anims.create({
      key,
      frames: frames.map((f) => ({ key: "player", frame: f })),
      frameRate: 8,
      repeat: -1,
    });
  }

  private setupMic() {
    const btn = document.getElementById("btnMic") as HTMLButtonElement | null;
    const stat = document.getElementById("micStatus");
    const asr = createASR("en-US");
    if (!btn || !stat) return;
    if (!asr.supported) { stat.textContent = "mic: unsupported (use keys)"; btn.disabled = true; return; }

    let running = false;
    const set = (k: keyof typeof this.dir, val: boolean)=> (this.dir[k] = val);

    btn.onclick = () => {
      if (!running) {
        asr.start((text, isFinal) => {
          if (!isFinal) { stat.textContent = "mic: listening…"; return; }
          const t = text.toLowerCase();

          // setupMic() の中
          for (const enemy of this.enemies.getChildren()) {
            const name = (enemy as Phaser.Physics.Arcade.Sprite).getData("name");
            if (t.includes(name)) {
              logger.cmd(`voice: attack ${name}`);
              this.shootSpread(enemy as Phaser.Physics.Arcade.Sprite);
              return;
            }
          }
          for (const rock of this.rocks.getChildren()) {
            const name = (rock as Phaser.GameObjects.Rectangle).getData("name");
            if (t.includes(name)) {
              logger.cmd(`voice: move to ${name}`);
              // this.moveToTarget(rock as Phaser.GameObjects.Rectangle);
              this.moveToRock(rock as Phaser.GameObjects.Rectangle);
              return;
            }
          }

          logger.cmd(`voice: ${t}`);

          // 移動（押下状態を切替）
          if (/\bforward\b/.test(t)) { set("forward", true);  set("back",false); set("left",false); set("right",false); }
          if (/\bback\b/.test(t))    { set("forward", false); set("back",true);  set("left",false); set("right",false); }
          if (/\bleft\b/.test(t))    { set("forward", false); set("back",false); set("left",true);  set("right",false); }
          if (/\bright\b/.test(t))   { set("forward", false); set("back",false); set("left",false); set("right",true); }
          if (/\bstop\b/.test(t))    { set("forward", false); set("back",false); set("left",false); set("right",false); }

          // “shoot” 単独なら最後に動いた向きへ
          if (/\bshoot\b/.test(t) && !/\bshoot (left|right|forward|back)\b/.test(t)) {
            this.shoot();
          }
        });
        running = true; btn.textContent = "⏹ Stop mic"; stat.textContent = "mic: listening…";
      } else {
        asr.stop(); running = false; btn.textContent = "🎤 Start mic"; stat.textContent = "mic: idle";
      }
    };

  }

  // === LoS / FOV / Range 判定 ===
  private hasLineOfSight(ax: number, ay: number, bx: number, by: number): boolean {
    // 岩に遮られていないか判定
    const ray = new Phaser.Geom.Line(ax, ay, bx, by);
    let blocked = false;
    this.rocks.children.iterate((go: Phaser.GameObjects.GameObject) => {
      if (blocked) return;
      const r = go as Phaser.GameObjects.Rectangle;
      const rect = new Phaser.Geom.Rectangle(r.x - r.width/2, r.y - r.height/2, r.width, r.height);
      if (Phaser.Geom.Intersects.LineToRectangle(ray, rect)) blocked = true;
    });
    return !blocked;
  }

  private inFOVAndRange(ex: number, ey: number, px: number, py: number, opts?: {
    fovDeg?: number; range?: number;
  }): boolean {
    const fovDeg = opts?.fovDeg ?? 100; // 視野角（例：±50°）
    const range  = opts?.range ?? 600;  // 射程
    const dx = px - ex, dy = py - ey;
    const dist = Math.hypot(dx, dy);
    if (dist > range) return false;

    // 敵の「向き」は未管理なので、敵→プレイヤー方向ベクトルをそのまま視線とみなす
    //（向き管理したいなら敵の回転等に合わせて angleDiff を計算）
    // ここではFOVは実質「どの方向でもOK」に近いが、将来の向き実装に備えて残す
    const angleToPlayer = Phaser.Math.Angle.Normalize(Math.atan2(dy, dx));
    const angleForward  = angleToPlayer; // 簡略：前方＝プレイヤー方向
    const angDiff = Phaser.Math.RadToDeg(Phaser.Math.Angle.Wrap(angleToPlayer - angleForward));
    return Math.abs(angDiff) <= fovDeg * 0.5;
  }

  private shootSpread(target: Phaser.Physics.Arcade.Sprite) {
    const num = 5;
    const base = Phaser.Math.Angle.Between(this.player.x, this.player.y, target.x, target.y);
    for (let i = 0; i < num; i++) {
      const angle = Phaser.Math.RadToDeg(base - 0.2 + 0.4 * (i / (num - 1)));
      this.spawnBullet(this.player.x, this.player.y, angle, 400, 8, 3000, 600);
    }
  }

  private getUniqueWord(pool: string[]): string {
    if (pool.length === 0) return "none";
    const i = Phaser.Math.Between(0, pool.length - 1);
    return pool.splice(i, 1)[0];
  }
  private moveToRock(target: Phaser.GameObjects.Rectangle) {
    this.dir.forward = this.dir.back = this.dir.left = this.dir.right = false;
    this.navTargetRock = target;
    logger.info(`Move: heading to rock "${target.getData("name")}"`);
  }

  private onArrived(r: Phaser.GameObjects.Rectangle) {
    this.player.setVelocity(0);
    // 念のため移動入力をクリア
    this.dir.forward = this.dir.back = this.dir.left = this.dir.right = false;

    const arrivedName = r.getData("name") || "rock";
    logger.info(`Arrived: touched target "${arrivedName}"`);
    this.navTargetRock = null;
  }

  // 1) spawnBullet の定義を置換
  private spawnBullet(
    x: number, y: number,
    angleDeg: number,
    speed = 500,
    radius = 8,
    lifeMs = 3000,
    armDelayMs = 300
  ) {
    const b = this.bullets.get(x, y, "bullet", 0, true) as Bullet | null;
    if (!b) return null;
    b.setActive(true).setVisible(true);
    b.configure({ speed, radius, lifespanMs: lifeMs, armDelayMs });

    const body = b.body as Phaser.Physics.Arcade.Body;
    body.enable = true;
    body.reset(x, y);
    b.fire(angleDeg, speed);
    return b;
  }

  // 2) プレイヤー発射（team引数削除）
  private shoot() {
    const px = this.player.x, py = this.player.y;
    const angleDeg = this.player.direction; // 0/90/180/270 degree
    this.spawnBullet(px, py, angleDeg, 400, 8, 1000, 300);
  }

}
```

<a id="app-src-scenes-TitleScene.ts"></a>
### 28. `app/src/scenes/TitleScene.ts`
- Size: 1156 bytes | LOC: 35 | SLOC: 26 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: 8c7bfab054f5

#### Brief
import Phaser from "phaser";

#### Auto Summary
import Phaser from "phaser";

#### Content

```typescript
import Phaser from "phaser";

export class TitleScene extends Phaser.Scene {
  constructor() {
    super("TitleScene");
  }

  preload() {
    this.load.audio("audio_title", "audio/title.mp3");
  }

  create() {
    const w = this.scale.width, h = this.scale.height;

    this.bgm = this.sound.add("audio_title", { loop: true, volume: 0.4 });
    this.bgm.play();

    this.cameras.main.setBackgroundColor(0x20242a);
    this.add.text(w / 2, h / 2 - 40, "Shout & Move", { font: "32px monospace", color: "#fff" }).setOrigin(0.5);
    this.add.text(w / 2, h / 2 + 10, "Say names or press keys", { font: "16px monospace", color: "#aaf" }).setOrigin(0.5);
    this.add.text(w / 2, h / 2 + 40, "Press SPACE / Click / Tap to Start", { font: "14px monospace", color: "#ccc" }).setOrigin(0.5);

    // ✅ 関数を先に定義
    const start = () => {
      this.bgm.stop();
      this.input.keyboard!.off("keydown-SPACE", start);
      this.input.off("pointerdown", start);
      this.scene.start("MainScene");
    };

    // ✅ その後でイベント登録
    this.input.keyboard!.on("keydown-SPACE", start);
    this.input.on("pointerdown", start);
  }
}
```

<a id="app-src-style.css"></a>
### 29. `app/src/style.css`
- Size: 1525 bytes | LOC: 98 | SLOC: 85 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: 0a7e82ceb45b

#### Brief
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;

#### Auto Summary
:root {

#### Content

```css
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

#app {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.vanilla:hover {
  filter: drop-shadow(0 0 2em #3178c6aa);
}

.card {
  padding: 2em;
}


.read-the-docs {
  color: #888;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}
```

<a id="app-src-typescript.svg"></a>
### 30. `app/src/typescript.svg`
- Size: 1435 bytes | LOC: 1 | SLOC: 1 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: f15a725e7a29

#### Brief
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="32" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 256"><path fill="#007ACC" d="M0 128v128h256V0H0z"></path><path fill="#FFF" d="m56.612 128.85l-.081 10.483h33.32v94.68h23.568v-94.68h33.321v-10.28c0-5.69-.122-10.444-.284-10.566c-.122-.162-20.4-.244-44.983-.203l-44.74.122l-.121 10.443Zm149.955-10.742c6.501 1.625 11.459 4.51 16.01 9.224c2.357 2.52 5.851 7.111 6.136 8.208c.08.325-11.053 7.802-17.798 11.988c-.244.162-1.22-.894-2.317-2.52c-3.291-4.795-6.745-6.867-12.028-7.233c-7.76-.528-12.759 3.535-12.718 10.321c0 1.992.284 3.17 1.097 4.795c1.707 3.536 4.876 5.649 14.832 9.956c18.326 7.883 26.168 13.084 31.045 20.48c5.445 8.249 6.664 21.415 2.966 31.208c-4.063 10.646-14.14 17.879-28.323 20.276c-4.388.772-14.79.65-19.504-.203c-10.28-1.828-20.033-6.908-26.047-13.572c-2.357-2.6-6.949-9.387-6.664-9.874c.122-.163 1.178-.813 2.356-1.504c1.138-.65 5.446-3.129 9.509-5.485l7.355-4.267l1.544 2.276c2.154 3.29 6.867 7.801 9.712 9.305c8.167 4.307 19.383 3.698 24.909-1.26c2.357-2.153 3.332-4.388 3.332-7.68c0-2.966-.366-4.266-1.91-6.501c-1.99-2.845-6.054-5.242-17.595-10.24c-13.206-5.69-18.895-9.224-24.096-14.832c-3.007-3.25-5.852-8.452-7.03-12.8c-.975-3.617-1.22-12.678-.447-16.335c2.723-12.76 12.353-21.659 26.25-24.3c4.51-.853 14.994-.528 19.424.569Z"></path></svg>

#### Auto Summary
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="32" height="32" preserveAspectRatio="xMidYMid mee

#### Content

```
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="32" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 256"><path fill="#007ACC" d="M0 128v128h256V0H0z"></path><path fill="#FFF" d="m56.612 128.85l-.081 10.483h33.32v94.68h23.568v-94.68h33.321v-10.28c0-5.69-.122-10.444-.284-10.566c-.122-.162-20.4-.244-44.983-.203l-44.74.122l-.121 10.443Zm149.955-10.742c6.501 1.625 11.459 4.51 16.01 9.224c2.357 2.52 5.851 7.111 6.136 8.208c.08.325-11.053 7.802-17.798 11.988c-.244.162-1.22-.894-2.317-2.52c-3.291-4.795-6.745-6.867-12.028-7.233c-7.76-.528-12.759 3.535-12.718 10.321c0 1.992.284 3.17 1.097 4.795c1.707 3.536 4.876 5.649 14.832 9.956c18.326 7.883 26.168 13.084 31.045 20.48c5.445 8.249 6.664 21.415 2.966 31.208c-4.063 10.646-14.14 17.879-28.323 20.276c-4.388.772-14.79.65-19.504-.203c-10.28-1.828-20.033-6.908-26.047-13.572c-2.357-2.6-6.949-9.387-6.664-9.874c.122-.163 1.178-.813 2.356-1.504c1.138-.65 5.446-3.129 9.509-5.485l7.355-4.267l1.544 2.276c2.154 3.29 6.867 7.801 9.712 9.305c8.167 4.307 19.383 3.698 24.909-1.26c2.357-2.153 3.332-4.388 3.332-7.68c0-2.966-.366-4.266-1.91-6.501c-1.99-2.845-6.054-5.242-17.595-10.24c-13.206-5.69-18.895-9.224-24.096-14.832c-3.007-3.25-5.852-8.452-7.03-12.8c-.975-3.617-1.22-12.678-.447-16.335c2.723-12.76 12.353-21.659 26.25-24.3c4.51-.853 14.994-.528 19.424.569Z"></path></svg>
```

<a id="app-tsconfig.json"></a>
### 31. `app/tsconfig.json`
- Size: 637 bytes | LOC: 26 | SLOC: 24 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: af1f75a8015c

#### Brief
{
  "compilerOptions": {

#### Auto Summary
{

#### Content

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "types": ["vite/client"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
```

<a id="Dockerfile"></a>
### 32. `Dockerfile`
- Size: 82 bytes | LOC: 6 | SLOC: 5 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: c5038ca61dc6

#### Brief
FROM node:20-bullseye

#### Auto Summary
FROM node:20-bullseye

#### Content

```dockerfile
FROM node:20-bullseye

WORKDIR /app
COPY app/package*.json ./
RUN npm ci
COPY . .
```

<a id="README.md"></a>
### 33. `README.md`
- Size: 415 bytes | LOC: 3 | SLOC: 2 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: b6520e02cb37

#### Brief
# [Shout and Movement](https://github.com/europanite/shout "Shout and Movement")

#### Auto Summary
[Shout and Movement](https://github.com/europanite/shout "Shout and Movement")

#### Content (verbatim)

```markdown
# [Shout and Movement](https://github.com/europanite/shout "Shout and Movement")

英単語を話して、コマンド入力し、キャラクターを動かす。モデルはFire and Movementである。2人の魔法少女がキャラクターが交互に敵を制圧しながら、縦長の世界を前進し、敵を倒していく。日本人が苦手な発音を使いわけることを目的としている。
```
