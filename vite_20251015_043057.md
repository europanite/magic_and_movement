<!-- P2M_REPORT -->
<!-- GENERATED at 2025-10-15 04:30:57 -->
# Project Export: vite

## Overview

- Root: `/home/skinner/magic_and_movement/vite`
- Files: **36**
- Total size: **6067641 bytes**
- Total LOC: 2149 | SLOC: 1694 | TODOs: 0

### Language mix
- typescript: 20
- plain: 11
- markdown: 1
- dockerfile: 1
- json: 1
- html: 1
- css: 1

### Top 12 largest files (bytes)
- `app/public/images/title.png` — 2975066 bytes
- `app/public/audio/title.mp3` — 1572393 bytes
- `app/public/audio/bgm.mp3` — 1339778 bytes
- `app/public/images/bullet.png` — 71431 bytes
- `app/src/scenes/MainScene.ts` — 20122 bytes
- `app/src/scenes/TitleScene.ts` — 9762 bytes
- `app/public/audio/bullet_timeout.mp3` — 9525 bytes
- `app/public/audio/character_destroy.mp3` — 9525 bytes
- `app/public/images/enemy_sheet.png` — 8041 bytes
- `app/public/images/witch_sheet.png` — 7286 bytes
- `app/src/entities/CharacterBase.ts` — 6166 bytes
- `app/src/entities/Bullet.ts` — 6062 bytes

### Top 12 longest files (LOC)
- `app/src/scenes/MainScene.ts` — 518 LOC
- `app/src/scenes/TitleScene.ts` — 259 LOC
- `app/src/entities/Bullet.ts` — 185 LOC
- `app/src/entities/CharacterBase.ts` — 182 LOC
- `app/src/entities/Player.ts` — 160 LOC
- `app/src/entities/Base.ts` — 148 LOC
- `app/src/effects/DeathFX.ts` — 98 LOC
- `app/src/style.css` — 98 LOC
- `app/src/logger.ts` — 82 LOC
- `app/src/utils/hitbox.ts` — 52 LOC
- `app/index.html` — 51 LOC
- `app/src/utils/projectile.ts` — 36 LOC

### Project tree (included subset)
```
vite/
├── app/
│   ├── public/
│   │   ├── audio/
│   │   │   ├── bgm.mp3
│   │   │   ├── bullet_timeout.mp3
│   │   │   ├── character_destroy.mp3
│   │   │   └── title.mp3
│   │   ├── images/
│   │   │   ├── bullet.png
│   │   │   ├── enemy_sheet.png
│   │   │   ├── title.png
│   │   │   └── witch_sheet.png
│   │   └── vite.svg
│   ├── src/
│   │   ├── audio/
│   │   │   ├── CharacterSound.ts
│   │   │   ├── EffectSound.ts
│   │   │   └── SoundManager.ts
│   │   ├── effects/
│   │   │   └── DeathFX.ts
│   │   ├── entities/
│   │   │   ├── Base.ts
│   │   │   ├── Boss.ts
│   │   │   ├── Bullet.ts
│   │   │   ├── CharacterBase.ts
│   │   │   ├── Enemy.ts
│   │   │   ├── Player.ts
│   │   │   └── Rock.ts
│   │   ├── scenes/
│   │   │   ├── MainScene.ts
│   │   │   └── TitleScene.ts
│   │   ├── utils/
│   │   │   ├── hitbox.ts
│   │   │   └── projectile.ts
│   │   ├── api.ts
│   │   ├── asr.ts
│   │   ├── counter.ts
│   │   ├── logger.ts
│   │   ├── main.ts
│   │   ├── style.css
│   │   └── typescript.svg
│   ├── .gitignore
│   ├── index.html
│   └── tsconfig.json
├── Dockerfile
└── README.md
```

## Table of contents (files)

- 1. [app/.gitignore](#app-.gitignore)
- 2. [app/index.html](#app-index.html)
- 3. [app/public/audio/bgm.mp3](#app-public-audio-bgm.mp3)
- 4. [app/public/audio/bullet_timeout.mp3](#app-public-audio-bullet_timeout.mp3)
- 5. [app/public/audio/character_destroy.mp3](#app-public-audio-character_destroy.mp3)
- 6. [app/public/audio/title.mp3](#app-public-audio-title.mp3)
- 7. [app/public/images/bullet.png](#app-public-images-bullet.png)
- 8. [app/public/images/enemy_sheet.png](#app-public-images-enemy_sheet.png)
- 9. [app/public/images/title.png](#app-public-images-title.png)
- 10. [app/public/images/witch_sheet.png](#app-public-images-witch_sheet.png)
- 11. [app/public/vite.svg](#app-public-vite.svg)
- 12. [app/src/api.ts](#app-src-api.ts)
- 13. [app/src/asr.ts](#app-src-asr.ts)
- 14. [app/src/audio/CharacterSound.ts](#app-src-audio-CharacterSound.ts)
- 15. [app/src/audio/EffectSound.ts](#app-src-audio-EffectSound.ts)
- 16. [app/src/audio/SoundManager.ts](#app-src-audio-SoundManager.ts)
- 17. [app/src/counter.ts](#app-src-counter.ts)
- 18. [app/src/effects/DeathFX.ts](#app-src-effects-DeathFX.ts)
- 19. [app/src/entities/Base.ts](#app-src-entities-Base.ts)
- 20. [app/src/entities/Boss.ts](#app-src-entities-Boss.ts)
- 21. [app/src/entities/Bullet.ts](#app-src-entities-Bullet.ts)
- 22. [app/src/entities/CharacterBase.ts](#app-src-entities-CharacterBase.ts)
- 23. [app/src/entities/Enemy.ts](#app-src-entities-Enemy.ts)
- 24. [app/src/entities/Player.ts](#app-src-entities-Player.ts)
- 25. [app/src/entities/Rock.ts](#app-src-entities-Rock.ts)
- 26. [app/src/logger.ts](#app-src-logger.ts)
- 27. [app/src/main.ts](#app-src-main.ts)
- 28. [app/src/scenes/MainScene.ts](#app-src-scenes-MainScene.ts)
- 29. [app/src/scenes/TitleScene.ts](#app-src-scenes-TitleScene.ts)
- 30. [app/src/style.css](#app-src-style.css)
- 31. [app/src/typescript.svg](#app-src-typescript.svg)
- 32. [app/src/utils/hitbox.ts](#app-src-utils-hitbox.ts)
- 33. [app/src/utils/projectile.ts](#app-src-utils-projectile.ts)
- 34. [app/tsconfig.json](#app-tsconfig.json)
- 35. [Dockerfile](#Dockerfile)
- 36. [README.md](#README.md)

---

## Files

<a id="app-.gitignore"></a>
### 1. `app/.gitignore`
- Size: 253 bytes | LOC: 24 | SLOC: 22 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: f97396057473

#### Brief
# Logs
logs

#### Auto Summary
# Logs

#### Content

```
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
```

<a id="app-index.html"></a>
### 2. `app/index.html`
- Size: 1232 bytes | LOC: 51 | SLOC: 46 | TODOs: 0 | Modified: 2025-10-15 01:18:58 | SHA1: 4db5b901e7be

#### Brief
<!doctype html>
<meta charset="utf-8" />

#### Auto Summary
<!doctype html>

#### Content

```html
<!doctype html>
<meta charset="utf-8" />
<title>Shout Demo</title>
<body style="margin:0;background:#000000">

  <!-- UIバー -->
  <div style="position:fixed;left:0;right:0;top:0;padding:8px 12px;
              background:#1f2530;color:#ffffff;font:14px/1 system-ui;display:flex;gap:8px;">
    <button id="btnMic" style="padding:6px 10px;">🎤 Start mic</button>
    <span id="micStatus">mic: idle</span>
  </div>

  <div 
    style="margin:0;"
  >
    <div 
      id="game-root" 
      style="
        background: #000000;
        margin:0;
    ">
    </div>

    <!-- <pre 
      id="log" 
      style="
      margin: 0;
      background: #000;
      color: #0f0;
      font: 12px/1.4 monospace;
      padding: 6px;
      border-top: 1px solid #222;
    ">
    </pre> -->

    <pre 
      id="log" 
      style="
        margin: 0;
        background: #000;
        color: #0f0;
        font: 12px/1.4 monospace;
        padding: 6px;
        border-top: 1px solid #222;
        height: 160px;        /* ← 固定の最大高さ（お好みで調整） */
        overflow: hidden;     /* ← スクロール禁止。はみ出しは切り捨て */
      ">

</div>
  <script type="module" src="/src/main.ts"></script>
</body>
```

<a id="app-public-audio-bgm.mp3"></a>
### 3. `app/public/audio/bgm.mp3`
- Size: 1339778 bytes | LOC: 0 | SLOC: 0 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: 
#### Content

```
```

<a id="app-public-audio-bullet_timeout.mp3"></a>
### 4. `app/public/audio/bullet_timeout.mp3`
- Size: 9525 bytes | LOC: 0 | SLOC: 0 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: 
#### Content

```
```

<a id="app-public-audio-character_destroy.mp3"></a>
### 5. `app/public/audio/character_destroy.mp3`
- Size: 9525 bytes | LOC: 0 | SLOC: 0 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: 
#### Content

```
```

<a id="app-public-audio-title.mp3"></a>
### 6. `app/public/audio/title.mp3`
- Size: 1572393 bytes | LOC: 0 | SLOC: 0 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: 
#### Content

```
```

<a id="app-public-images-bullet.png"></a>
### 7. `app/public/images/bullet.png`
- Size: 71431 bytes | LOC: 0 | SLOC: 0 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: 
#### Content

```
```

<a id="app-public-images-enemy_sheet.png"></a>
### 8. `app/public/images/enemy_sheet.png`
- Size: 8041 bytes | LOC: 0 | SLOC: 0 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: 
#### Content

```
```

<a id="app-public-images-title.png"></a>
### 9. `app/public/images/title.png`
- Size: 2975066 bytes | LOC: 0 | SLOC: 0 | TODOs: 0 | Modified: 2025-10-14 17:49:18 | SHA1: 
#### Content

```
```

<a id="app-public-images-witch_sheet.png"></a>
### 10. `app/public/images/witch_sheet.png`
- Size: 7286 bytes | LOC: 0 | SLOC: 0 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: 
#### Content

```
```

<a id="app-public-vite.svg"></a>
### 11. `app/public/vite.svg`
- Size: 1497 bytes | LOC: 1 | SLOC: 1 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: f7f39d7237b7

#### Brief
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

#### Auto Summary
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid 

#### Content

```
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
```

<a id="app-src-api.ts"></a>
### 12. `app/src/api.ts`
- Size: 945 bytes | LOC: 25 | SLOC: 22 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: 678d687004d6

#### Brief
const BASE = import.meta.env.VITE_API_BASE as string | undefined;

#### Auto Summary
const BASE = import.meta.env.VITE_API_BASE as string | undefined;

#### Content

```typescript
const BASE = import.meta.env.VITE_API_BASE as string | undefined;

export async function createSession(): Promise<string> {
  if (!BASE) throw new Error("VITE_API_BASE not set");
  const r = await fetch(`${BASE}/commands/sessions`, { method: "POST" });
  const j = await r.json();
  return j.session_id as string;
}

export async function postRaw(sessionId: string, text: string) {
  if (!BASE) throw new Error("VITE_API_BASE not set");
  await fetch(`${BASE}/commands`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ session_id: sessionId, raw_text: text }),
  });
}

export async function pollNext(sessionId: string) {
  if (!BASE) throw new Error("VITE_API_BASE not set");
  const r = await fetch(`${BASE}/commands/next?session_id=${sessionId}`);
  if (!r.ok) return null;
  const t = await r.text();
  return t ? JSON.parse(t) as { command: "TURN_RIGHT"|"TURN_LEFT"|"LIGHT" } : null;
}
```

<a id="app-src-asr.ts"></a>
### 13. `app/src/asr.ts`
- Size: 820 bytes | LOC: 27 | SLOC: 22 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: 347ae9fd92e6

#### Brief
export type OnText = (finalText: string, isFinal: boolean) => void;

#### Auto Summary
export type OnText = (finalText: string, isFinal: boolean) => void;

#### Content

```typescript
export type OnText = (finalText: string, isFinal: boolean) => void;

export function createASR(lang = "en-US") {
  // @ts-expect-error webkit prefix for Chrome
  const SR = (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition;
  if (!SR) return { supported: false, start: () => {}, stop: () => {} };

  const rec = new SR();
  rec.lang = lang;
  rec.continuous = true;
  rec.interimResults = true;

  let onText: OnText | null = null;
  rec.onresult = (e: SpeechRecognitionEvent) => {
    if (!onText) return;
    for (let i = e.resultIndex; i < e.results.length; i++) {
      const r = e.results[i];
      onText(r[0].transcript.trim(), r.isFinal);
    }
  };

  return {
    supported: true,
    start(cb: OnText) { onText = cb; rec.start(); },
    stop() { rec.stop(); onText = null; }
  };
}
```

<a id="app-src-audio-CharacterSound.ts"></a>
### 14. `app/src/audio/CharacterSound.ts`
- Size: 437 bytes | LOC: 19 | SLOC: 15 | TODOs: 0 | Modified: 2025-10-14 17:22:31 | SHA1: ad31451dc9a7

#### Brief
app/src/audio/CharacterSound.ts

#### Auto Summary
// app/src/audio/CharacterSound.ts

#### Content

```typescript
// app/src/audio/CharacterSound.ts
import Phaser from "phaser";

export class CharacterSound {
  constructor(private scene: Phaser.Scene) {}

  playDeath(kind: "player" | "enemy" | "boss") {
    const key = {
      player: "se_player_die",
      enemy: "se_enemy_die",
      boss: "se_boss_die",
    }[kind];
    this.scene.sound.play(key, { volume: 0.8 });
  }

  playHit() {
    this.scene.sound.play("se_hit", { volume: 0.6 });
  }
}
```

<a id="app-src-audio-EffectSound.ts"></a>
### 15. `app/src/audio/EffectSound.ts`
- Size: 785 bytes | LOC: 34 | SLOC: 28 | TODOs: 0 | Modified: 2025-10-14 17:36:13 | SHA1: 4467e11bde45

#### Brief
app/src/audio/EffectSound.ts

#### Auto Summary
// app/src/audio/EffectSound.ts

#### Content

```typescript
// app/src/audio/EffectSound.ts
import Phaser from "phaser";

export class EffectSound {
  constructor(private scene: Phaser.Scene) {}

  bulletFire() {
    const key = "se_bullet_fire";
    if (this.scene.cache.audio.exists(key)) {
      this.scene.sound.play(key, { volume: 0.55 });
    }
  }

  bulletCollision() {
    const key = "se_bullet_collision";
    if (this.scene.cache.audio.exists(key)) {
      this.scene.sound.play(key, { volume: 0.6 });
    }
  }

  bulletTimeout() {
    const key = "se_bullet_timeout";
    if (this.scene.cache.audio.exists(key)) {
      this.scene.sound.play(key, { volume: 0.5 });
    }
  }

  uiSelect() {
    const key = "se_ui_select";
    if (this.scene.cache.audio.exists(key)) {
      this.scene.sound.play(key, { volume: 0.5 });
    }
  }
}
```

<a id="app-src-audio-SoundManager.ts"></a>
### 16. `app/src/audio/SoundManager.ts`
- Size: 660 bytes | LOC: 24 | SLOC: 19 | TODOs: 0 | Modified: 2025-10-14 17:21:51 | SHA1: 8bd03df3d76d

#### Brief
app/src/audio/SoundManager.ts

#### Auto Summary
// app/src/audio/SoundManager.ts

#### Content

```typescript
// app/src/audio/SoundManager.ts
import Phaser from "phaser";
import { CharacterSound } from "./CharacterSound";
import { EffectSound } from "./EffectSound";

export class SoundManager {
  private static _inst: SoundManager;
  private scene!: Phaser.Scene;
  public characters!: CharacterSound;
  public effects!: EffectSound;

  static init(scene: Phaser.Scene) {
    if (!this._inst) this._inst = new SoundManager(scene);
    return this._inst;
  }

  static get I() { return this._inst; }

  private constructor(scene: Phaser.Scene) {
    this.scene = scene;
    this.characters = new CharacterSound(scene);
    this.effects = new EffectSound(scene);
  }
}
```

<a id="app-src-counter.ts"></a>
### 17. `app/src/counter.ts`
- Size: 274 bytes | LOC: 9 | SLOC: 9 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: 5133075ae32c

#### Brief
export function setupCounter(element: HTMLButtonElement) {
  let counter = 0

#### Auto Summary
export function setupCounter(element: HTMLButtonElement) {

#### Content

```typescript
export function setupCounter(element: HTMLButtonElement) {
  let counter = 0
  const setCounter = (count: number) => {
    counter = count
    element.innerHTML = `count is ${counter}`
  }
  element.addEventListener('click', () => setCounter(counter + 1))
  setCounter(0)
}
```

<a id="app-src-effects-DeathFX.ts"></a>
### 18. `app/src/effects/DeathFX.ts`
- Size: 3344 bytes | LOC: 98 | SLOC: 77 | TODOs: 0 | Modified: 2025-10-15 04:20:41 | SHA1: e0407493e5b8

#### Brief
app/src/effects/DeathFX.ts

#### Auto Summary
// app/src/effects/DeathFX.ts

#### Content

```typescript
// app/src/effects/DeathFX.ts
import Phaser from "phaser";

export type DeathKind = "player" | "enemy" | "boss" | "bullet_timeout" | "bullet_collision";

function isDeathKind(v: any): v is DeathKind {
  return v === "player" || v === "enemy" || v === "boss" || v === "bullet_timeout" || v === "bullet_collision";
}

export class DeathFX {
  /** 種類別の推奨SEキー（★ default を用意） */
  static seKey(kind: DeathKind): string {
    switch (kind) {
      case "player":           return "se_player_die";
      case "boss":             return "se_boss_die";
      case "enemy":            return "se_enemy_die";
      case "bullet_timeout":   return "se_bullet_timeout";
      case "bullet_collision": return "se_bullet_collision";
      default:                 return "se_enemy_die";
    }
  }

  static playSE(scene: Phaser.Scene, key: string, detune = 0, volume = 0.8) {
    if (!scene.cache.audio.exists(key)) {
      console.warn(`[SE] Missing audio key: ${key}`);
      return;
    }
    scene.sound.play(key, { detune, volume } as any);
  }

  /**
   * 破裂演出（Phaser 3.60+ 互換）
   * - パーティクルを使わず、小さなスプライトを放射状に飛ばしてフェードアウト
   * - 余計なマネージャを使わないので v3.60 の削除APIに触れない
   */
  static burstParticles(scene: Phaser.Scene, x: number, y: number, tint: number) {
    const texKey = "bullet";
    if (!scene.textures.exists(texKey)) return;

    const COUNT = 20;
    for (let i = 0; i < COUNT; i++) {
      const img = scene.add.image(x, y, texKey);
      img.setOrigin(0.5).setScale(0.35).setAlpha(1).setDepth(1000).setTint(tint);

      // 角度と距離をランダムに
      const ang = Phaser.Math.FloatBetween(0, Math.PI * 2);
      const dist = Phaser.Math.Between(60, 180);
      const dur = Phaser.Math.Between(380, 520);

      const tx = x + Math.cos(ang) * dist;
      const ty = y + Math.sin(ang) * dist;

      scene.tweens.add({
        targets: img,
        x: tx,
        y: ty,
        scale: 0,
        alpha: 0,
        duration: dur,
        ease: "Cubic.easeOut",
        onComplete: () => img.destroy(),
      });
    }
  }

  static tweenVanish(scene: Phaser.Scene, sprite: Phaser.GameObjects.Sprite, onComplete?: () => void) {
    scene.tweens.add({
      targets: sprite,
      duration: 250,
      scaleX: sprite.scaleX * 0.7,
      scaleY: sprite.scaleY * 0.7,
      alpha: 0,
      onComplete: () => onComplete?.(),
    });
  }

  /** 破壊演出のメイン入口（kindは安全にフォールバック） */
  static play(scene: Phaser.Scene, sprite: Phaser.GameObjects.Sprite, rawKind: any) {
    const kind: DeathKind = isDeathKind(rawKind) ? rawKind : "enemy";

    // 1) SE
    this.playSE(scene, this.seKey(kind), kind === "boss" ? -200 : 0, kind === "player" ? 0.9 : 0.7);

    // 2) 放射スプライト（色味を種類で少し変える）
    const tint =
      kind === "player" ? 0x80d0ff :
      kind === "boss"   ? 0xff8080 :
      0xffe080;
    this.burstParticles(scene, sprite.x, sprite.y, tint);

    // 3) カメラシェイク
    const cam = scene.cameras.main;
    cam.shake(kind === "boss" ? 200 : 120, kind === "boss" ? 0.01 : 0.006);

    // 4) 本体フェード → 破棄
    this.tweenVanish(scene, sprite, () => sprite.destroy());
  }
}
```

<a id="app-src-entities-Base.ts"></a>
### 19. `app/src/entities/Base.ts`
- Size: 4113 bytes | LOC: 148 | SLOC: 120 | TODOs: 0 | Modified: 2025-10-15 04:15:22 | SHA1: 3c4d4ab03589

#### Brief
app/src/entities/Base.ts

#### Auto Summary
// app/src/entities/Base.ts

#### Content

```typescript
// app/src/entities/Base.ts
import Phaser from "phaser";
import { DeathFX } from "../effects/DeathFX";
import type { DeathKind } from "../effects/DeathFX";
import { syncHitboxToDisplay as syncHB } from "../utils/hitbox";

export type BaseOptions = {
  scale?: number;
  immovable?: boolean;
  collideWorldBounds?: boolean;
  showLabel?: boolean;
  labelDepth?: number;
  drawHitbox?: boolean;
  hitboxShape?: "circle" | "rect";
  hitboxScale?: number;
  hitboxPadding?: number;
};

export class Base extends Phaser.Physics.Arcade.Sprite {
  public maxHp = 1;
  public hp = 1;

  protected nameTag?: Phaser.GameObjects.Text;
  protected opts: Required<BaseOptions>;

  constructor(
    scene: Phaser.Scene,
    x: number,
    y: number,
    texture: string,
    frame: number | string = 0,
    public displayName: string = "",
    maxHp = 1,
    options: BaseOptions = {}
  ) {
    super(scene, x, y, texture, frame);

    this.opts = {
      scale: options.scale ?? 1,
      immovable: options.immovable ?? false,
      collideWorldBounds: options.collideWorldBounds ?? false,
      showLabel: options.showLabel ?? true,
      labelDepth: options.labelDepth ?? 100,
      drawHitbox: options.drawHitbox ?? true,
      hitboxShape: options.hitboxShape ?? "circle",
      hitboxScale: options.hitboxScale ?? 1.0,
      hitboxPadding: options.hitboxPadding ?? 0,
    };

    this.maxHp = maxHp;
    this.hp = maxHp;

    scene.add.existing(this);
    scene.physics.add.existing(this);

    this.setOrigin(0.5, 0.5);
    if (this.opts.scale !== 1) this.setScale(this.opts.scale);

    const body = this.body as Phaser.Physics.Arcade.Body;
    body.setImmovable(!!this.opts.immovable);
    body.setCollideWorldBounds(!!this.opts.collideWorldBounds);

    this.syncHitboxToDisplay();

    if (this.opts.showLabel) {
      this.nameTag = scene.add.text(this.x, this.y - this.displayHeight * 0.5 - 8, this.displayName, {
        fontSize: "12px",
        color: "#fff",
        stroke: "#000",
        strokeThickness: 2,
      }).setDepth(this.opts.labelDepth);
    }
  }

  protected syncHitboxToDisplay() {
    const body = this.body as Phaser.Physics.Arcade.Body;
    if (!body) return;
    syncHB(this as any, {
      hitboxShape: this.opts.hitboxShape,
      scaleFactor: this.opts.hitboxScale,
      padding: this.opts.hitboxPadding,
    });
  }

  setScale(x: number, y?: number): this {
    super.setScale(x, y);
    if (this.body) this.syncHitboxToDisplay();
    return this;
  }

  setFrame(frame: string | number): this {
    super.setFrame(frame);
    if (this.body) this.syncHitboxToDisplay();
    return this;
  }

  /** HPを減算し、0以下なら死ぬ */
  public takeDamage(n = 1) {
    this.hp = Math.max(0, this.hp - n);
    if (this.hp <= 0) this.die();
  }

  /** 外部からも死亡判定を参照可能に */
  public isDead(): boolean {
    return this.hp <= 0 || !this.active;
  }

  protected die() {
    // 再入防止
    if (this.getData("__dying")) return;
    this.setData("__dying", true);

    this.nameTag?.destroy();

    // kind フォールバックを強化（未設定や想定外でも "enemy" に統一）
    const raw = this.getData("kind");
    const kind: DeathKind =
      raw === "player" ||
      raw === "enemy" ||
      raw === "boss" ||
      raw === "bullet_timeout" ||
      raw === "bullet_collision"
        ? (raw as DeathKind)
        : "enemy";
    if (raw !== kind) this.setData("kind", kind);

    // 即時無効化
    this.setActive(false).setVisible(false);
    const body = this.body as Phaser.Physics.Arcade.Body | undefined;
    if (body) body.enable = false;

    // エフェクト発火（破棄は DeathFX 側で）
    DeathFX.play(this.scene, this as unknown as Phaser.GameObjects.Sprite, kind);
  }

  /** 1フレームごとにHP=0の個体を整理 */
  preUpdate(time: number, delta: number) {
    super.preUpdate(time, delta);
    if (this.hp <= 0 && this.active) {
      this.die();
      return;
    }

    if (this.nameTag && this.active) {
      this.nameTag.setPosition(this.x, this.y - this.displayHeight * 0.5 - 8);
    }
  }
}
```

<a id="app-src-entities-Boss.ts"></a>
### 20. `app/src/entities/Boss.ts`
- Size: 467 bytes | LOC: 16 | SLOC: 14 | TODOs: 0 | Modified: 2025-10-15 03:34:39 | SHA1: 80c5c73dd39c

#### Brief
app/src/entities/Boss.ts

#### Auto Summary
// app/src/entities/Boss.ts

#### Content

```typescript
// app/src/entities/Boss.ts
import Phaser from "phaser";
import { CharacterBase } from "./CharacterBase";

export class Boss extends CharacterBase {
  constructor(scene: Phaser.Scene, x: number, y: number, name: string, maxHp = 30) {
    super(scene, x, y, "boss", 0, name, maxHp, {
      sounds: { death: "se_boss_die" },
      hitboxShape: "circle",
      hitboxScale: 0.45,
      hitboxPadding: 0,
      scale: 2.5,
    });
    this.setData("kind", "boss");
  }
}
```

<a id="app-src-entities-Bullet.ts"></a>
### 21. `app/src/entities/Bullet.ts`
- Size: 6062 bytes | LOC: 185 | SLOC: 141 | TODOs: 0 | Modified: 2025-10-15 04:11:27 | SHA1: 988f704e8ac7

#### Brief
app/src/entities/Bullet.ts

#### Auto Summary
// app/src/entities/Bullet.ts

#### Content

```typescript
// app/src/entities/Bullet.ts
import Phaser from "phaser";
import { Base } from "./Base";
import { logger } from "../logger";
import { SoundManager } from "../audio/SoundManager";

/** 弾の生成・挙動に関するオプション */
export interface BulletOptions {
  /** 像の移動速度(px/s) */
  speed: number;
  /** 自然消滅までの寿命(ms) */
  lifespanMs: number;
  /** 弾の見た目半径（display 半径） */
  radius: number;
  /** 起爆可能になるまでの遅延(ms) — 時限信管 */
  armDelayMs: number;
  /** 発射者（自己衝突防止用） */
  owner?: Phaser.GameObjects.GameObject;
}

/**
 * 弾（Arcade Physics）
 * 対策A：生成から常に body.enable = true にし、当たり判定の可否は armed フラグで制御する。
 */
export class Bullet extends Base {
  private speed = 500;
  private lifespanMs = 3000;
  private armDelayMs = 300;

  private bornAt = 0;
  private armed = false;
  private owner?: Phaser.GameObjects.GameObject;

  /** 内部メモ：角度（度数法） */
  private angleDeg = 0;

  constructor(
    scene: Phaser.Scene,
    x: number,
    y: number,
    options: Partial<BulletOptions> = {}
  ) {
    // テクスチャ名は "bullet" 前提（public/images/bullet.png）
    // 弾は当たり判定を円形で扱うのが前提
    super(scene, x, y, "bullet", 0, "bullet", 1, {
      hitboxShape: "circle",
      hitboxScale: 1.0,
      hitboxPadding: 0,
      showLabel: false,
      drawHitbox: false,
      collideWorldBounds: false,
      immovable: false,
      scale: 1,
      labelDepth: 100,
    });

    this.setOrigin(0.5, 0.5);

    // 既定値を反映
    if (options.speed      !== undefined) this.speed      = options.speed;
    if (options.lifespanMs !== undefined) this.lifespanMs = options.lifespanMs;
    if (options.armDelayMs !== undefined) this.armDelayMs = options.armDelayMs;
    if (options.owner      !== undefined) this.owner      = options.owner;

    // 見た目サイズ（display）を半径ベースで反映
    const r = options.radius ?? 8;
    this.setDisplaySize(r * 2, r * 2);

    // Arcade Body の初期設定
    const body = this.body as Phaser.Physics.Arcade.Body;
    body.setAllowGravity(false);
    body.setBounce(0, 0);
    body.setFriction(0, 0);
    body.setCollideWorldBounds(false);
    // ★ 対策A：ここで body.enable を false にしない（常に true のまま移動させる）

    // ワールド外での自然消滅を拾いたい場合は onWorldBounds を使う
    // ただし collideWorldBounds=false のため、明示的に発生させたい場合はシーン側でハンドリング
    body.onWorldBounds = true;

    // worldbounds 経由の消滅（必要に応じて）
    this.scene.physics.world.on("worldbounds", (b: Phaser.Physics.Arcade.Body) => {
      if (b.gameObject === this) this.vanishAs("bullet_timeout");
    });

    // メタデータ（効果音選別などに使用）
    this.setDataEnabled();
    this.setData("kind", "bullet");
  }

  /** 生成後にパラメータを上書き（チェーン可） */
  configure(opts: Partial<BulletOptions>) {
    if (opts.speed      !== undefined) this.speed      = opts.speed;
    if (opts.lifespanMs !== undefined) this.lifespanMs = opts.lifespanMs;
    if (opts.armDelayMs !== undefined) this.armDelayMs = opts.armDelayMs;
    if (opts.owner      !== undefined) this.owner      = opts.owner;
    if (opts.radius     !== undefined) this.setDisplaySize(opts.radius * 2, opts.radius * 2);
    return this;
  }

  /** 所有者（発射者）を取得 */
  getOwner() { return this.owner; }

  /** 武装（起爆可能）状態か */
  isArmed() { return this.armed; }

  /**
   * 命中可否（process フィルタや onOverlap 内で利用）
   * - アーム前（未武装）は当たらない
   * - 所有者（発射者）には当たらない
   */
  canHit(target: Phaser.GameObjects.GameObject): boolean {
    if (!this.armed) return false;
    if (this.owner && (this.owner === target)) return false;
    return true;
  }

  /**
   * 発射（与角度は度数法）
   * - ★対策A：body.enable は切り替えない
   * - アーム遅延は this.armed を遅延で true に
   */
  fire(angleDeg: number, speedOverride?: number) {
    this.angleDeg = angleDeg;
    const spd = speedOverride ?? this.speed;

    // ベロシティ設定
    const a = Phaser.Math.DegToRad(angleDeg);
    const vx = Math.cos(a) * spd;
    const vy = Math.sin(a) * spd;

    const body = this.body as Phaser.Physics.Arcade.Body;
    body.setVelocity(vx, vy);

    // 存在管理
    this.setActive(true).setVisible(true);
    this.bornAt = this.scene.time.now;

    // 起動SE（存在すれば）
    SoundManager.I?.effects?.bulletFire();

    // ★★ 武装は遅延してから
    this.armed = false;
    if (this.armDelayMs <= 0) {
      this.armed = true;
    } else {
      this.scene.time.delayedCall(this.armDelayMs, () => {
        // すでに消滅していれば何もしない
        if (!this.active) return;
        this.armed = true;
      });
    }
  }

  /**
   * 何かに当たった/寿命切れなどで消滅する際の統一口
   * kind:
   *  - "bullet_timeout" …… 寿命/範囲外
   *  - "bullet_collision" … 衝突（弾同士・対象命中含む）
   */
  private vanishAs(kind: "bullet_timeout" | "bullet_collision") {
    // 種類をメタデータに入れて Base#die → DeathFX/Sound 側に渡す
    this.setData("kind", kind);
    this.die();
  }

  /** 外部からのダメージ（弾×弾など） */
  override takeDamage(n = 1) {
    if (this.active && !this.getData("kind")) {
      this.setData("kind", "bullet_collision");
    }
    super.takeDamage(n);
  }

  /** 1フレームごとの更新：寿命判定のみ */
  preUpdate(time: number, delta: number) {
    super.preUpdate(time, delta);
    if (!this.active) return;

    // 自然消滅（寿命）
    if (time - this.bornAt >= this.lifespanMs) {
      this.vanishAs("bullet_timeout");
    }
  }
}
```

<a id="app-src-entities-CharacterBase.ts"></a>
### 22. `app/src/entities/CharacterBase.ts`
- Size: 6166 bytes | LOC: 182 | SLOC: 144 | TODOs: 0 | Modified: 2025-10-15 03:50:27 | SHA1: 7aadec313fa2

#### Brief
app/src/entities/CharacterBase.ts

#### Auto Summary
// app/src/entities/CharacterBase.ts

#### Content

```typescript
// app/src/entities/CharacterBase.ts
import Phaser from "phaser";
import { Base } from "./Base";
import { DeathFX } from "../effects/DeathFX";
import { SoundManager } from "../audio/SoundManager";

/** Character 個別の効果音キー */
export type CharacterSoundProfile = {
  death?: string;   // 撃破（死亡）時のSEキー
  hit?: string;     // 被弾時のSEキー（必要なら）
  attack?: string;  // 攻撃時のSEキー（必要なら）
};

export type CharacterBaseOptions = ConstructorParameters<typeof Base>[6] & {
  sounds?: CharacterSoundProfile;
};

/** シーン側に実装されている想定の弾生成 API  */
type SceneWithSpawnBullet = Phaser.Scene & {
  spawnBullet?: (
    x: number,
    y: number,
    angleDeg: number,
    speed?: number,
    radius?: number,
    lifespanMs?: number,
    armDelayMs?: number
  ) => void;
};

/** 武器の既定パラメータ（spawnBullet の引数に対応） */
export type WeaponConfig = {
  speed: number;        // 発射速度
  radius: number;       // 弾の見た目半径（displaySize の半径想定）
  lifespanMs: number;   // 弾の寿命
  armDelayMs: number;   // アーム（起爆可）までの遅延
  cooldownMs: number;   // 射撃クールダウン
};

export type ShootOverrides = Partial<Omit<WeaponConfig, "cooldownMs">>;

export class CharacterBase extends Base {
  protected sounds: Required<CharacterSoundProfile> = { death: "", hit: "", attack: "" };

  /** 共有武器設定（各キャラで上書き可） */
  protected weapon: WeaponConfig = {
    speed: 300,
    radius: 8,
    lifespanMs: 2500,
    armDelayMs: 300,
    cooldownMs: 140,
  };

  /** クールダウン管理 */
  protected lastShotAt = 0;

  constructor(
    scene: Phaser.Scene,
    x: number,
    y: number,
    texture: string,
    frame: number | string,
    displayName: string,
    maxHp = 1,
    opts: CharacterBaseOptions = {}
  ) {
    super(scene, x, y, texture, frame, displayName, maxHp, opts);
    if (opts?.sounds) this.sounds = { ...this.sounds, ...opts.sounds };
  }

  /** 武器パラメータをキャラ単位で上書き */
  public setWeapon(config: Partial<WeaponConfig>) {
    this.weapon = { ...this.weapon, ...config };
    return this;
  }

  /** クールダウンを考慮して撃てるか？ */
  public canShoot(now = this.scene.time.now): boolean {
    return (now - this.lastShotAt) >= this.weapon.cooldownMs;
  }

  /** 単発射撃：角度（度数法）必須。Override で速度/寿命/半径/アーム遅延を上書き可。 */
  public shoot(angleDeg: number, overrides: ShootOverrides = {}): boolean {
    const scene = this.scene as SceneWithSpawnBullet;
    const now = this.scene.time.now;
    if (!this.canShoot(now)) return false;
    if (typeof scene.spawnBullet !== "function") {
      console.warn("[CharacterBase] scene.spawnBullet が見つかりません。");
      return false;
    }

    const speed      = overrides.speed      ?? this.weapon.speed;
    const radius     = overrides.radius     ?? this.weapon.radius;
    const lifespanMs = overrides.lifespanMs ?? this.weapon.lifespanMs;
    const armDelayMs = overrides.armDelayMs ?? this.weapon.armDelayMs;

    scene.spawnBullet(this.x, this.y, angleDeg, speed, radius, lifespanMs, armDelayMs);
    this.lastShotAt = now;

    // 攻撃SE（あれば）
    if (this.sounds.attack) {
      this.scene.sound.play(this.sounds.attack, { volume: 0.6 });
    }

    return true;
  }

  /**
   * 扇状拡散射撃：
   *  centerDeg … 中心角度（度数法）
   *  count …… 発射数（2以上）
   *  spreadDeg … 全体の扇角（左右合計）
   */
  public shootSpread(centerDeg: number, count = 5, spreadDeg = 30, overrides: ShootOverrides = {}): boolean {
    if (count <= 0) return false;
    const scene = this.scene as SceneWithSpawnBullet;
    const now = this.scene.time.now;
    if (!this.canShoot(now)) return false;
    if (typeof scene.spawnBullet !== "function") {
      console.warn("[CharacterBase] scene.spawnBullet が見つかりません。");
      return false;
    }

    const speed      = overrides.speed      ?? this.weapon.speed;
    const radius     = overrides.radius     ?? this.weapon.radius;
    const lifespanMs = overrides.lifespanMs ?? this.weapon.lifespanMs;
    const armDelayMs = overrides.armDelayMs ?? this.weapon.armDelayMs;

    if (count === 1) {
      scene.spawnBullet(this.x, this.y, centerDeg, speed, radius, lifespanMs, armDelayMs);
    } else {
      const step = spreadDeg / (count - 1);
      const start = centerDeg - spreadDeg / 2;
      for (let i = 0; i < count; i++) {
        const ang = start + step * i;
        scene.spawnBullet(this.x, this.y, ang, speed, radius, lifespanMs, armDelayMs);
      }
    }

    this.lastShotAt = now;

    // 攻撃SE（あれば）
    if (this.sounds.attack) {
      this.scene.sound.play(this.sounds.attack, { volume: 0.6 });
    }

    return true;
  }

  // ===== 死亡処理：既存実装を踏襲しつつ安定化 =====
  protected override die() {
    // ① 再入防止
    if (this.getData("__dying")) return;
    this.setData("__dying", true);

    this.nameTag?.destroy();

    const kind = (this.getData("kind") as "player" | "enemy" | "boss") ?? "enemy";

    // ② まず無効化（preUpdate で再実行されないように）
    this.setActive(false).setVisible(false);
    const body = this.body as Phaser.Physics.Arcade.Body | undefined;
    if (body) body.enable = false;

    // ③ SE：SoundManager を優先。なければ DeathFX 側のデフォルトを利用可能。
    SoundManager.I?.characters?.playDeath(kind);

    // ④ 視覚演出（粒子・シェイク）
    DeathFX.burstParticles(
      this.scene,
      this.x,
      this.y,
      kind === "player" ? 0x80d0ff : kind === "boss" ? 0xff8080 : 0xffe080
    );
    this.scene.cameras.main.shake(kind === "boss" ? 200 : 120, kind === "boss" ? 0.01 : 0.006);

    // ⑤ tween 完了時に破棄（destroy はここだけ）
    DeathFX.tweenVanish(this.scene, this as unknown as Phaser.GameObjects.Sprite, () => {
      if (!this.destroyed) this.destroy();
    });
  }
}
```

<a id="app-src-entities-Enemy.ts"></a>
### 23. `app/src/entities/Enemy.ts`
- Size: 330 bytes | LOC: 11 | SLOC: 10 | TODOs: 0 | Modified: 2025-10-14 21:50:03 | SHA1: 1f2c6f66f6c2

#### Brief
import Phaser from "phaser";
import { CharacterBase } from "./CharacterBase";

#### Auto Summary
import Phaser from "phaser";

#### Content

```typescript
import Phaser from "phaser";
import { CharacterBase } from "./CharacterBase";

export class Enemy extends CharacterBase {
  constructor(scene: Phaser.Scene, x: number, y: number, name: string) {
    super(scene, x, y, "enemy", 0, name, 1, {
      sounds: { death: "se_enemy_die" },
    });
    this.setData("kind", "enemy");
  }
}
```

<a id="app-src-entities-Player.ts"></a>
### 24. `app/src/entities/Player.ts`
- Size: 5338 bytes | LOC: 160 | SLOC: 122 | TODOs: 0 | Modified: 2025-10-15 03:09:41 | SHA1: d5f8bd5e36d1

#### Brief
import Phaser from "phaser";
import { CharacterBase } from "./CharacterBase";

#### Auto Summary
import Phaser from "phaser";

#### Content

```typescript
import Phaser from "phaser";
import { CharacterBase } from "./CharacterBase";
import { logger } from "../logger";

export class Player extends CharacterBase {
  public direction: number = 90;

  // 自動移動
  private moveTarget: Phaser.Math.Vector2 | null = null;
  private targetRock: Phaser.GameObjects.Rectangle | null = null;
  private moveSpeed = 180;
  private facing: "right" | "left" | "forward" | "back" = "forward";
  private interrupted = false;
  private clampEnabled = false;

constructor(scene: Phaser.Scene, x: number, y: number, name = "you", maxHp = 5) {
  super(scene, x, y, "player", 0, name, maxHp, {
    sounds: { death: "se_player_die" },
    collideWorldBounds: true, // ←★追加！
  });
  this.setData("kind", "player");
}

  /**
   * 岩の名前を呼んだときに MainScene から呼ばれる想定のAPI
   * - 目的地を岩の中心座標に設定
   * - 目的岩の参照を保持（当たり判定チェックで使用）
   */
  moveToRock(target: Phaser.GameObjects.Rectangle) {
    this.moveTarget = new Phaser.Math.Vector2(target.x, target.y);
    this.targetRock = target;
    logger.info(`Move: heading to rock "${target.getData("name")}"`);
  }

  private playWalkAnim() {
    const key = {
      right:   "walk-right",
      left:    "walk-left",
      forward: "walk-forward",
      back:    "walk-back",
    }[this.facing];
    if (this.anims.currentAnim?.key !== key) {
      this.anims.play(key, true);
    }
  }

  public isAutoMoving(): boolean {
    return !!this.moveTarget;
  }

  /**
   * 自動移動中は「プレイヤー×岩の collider」を一時的に無効化するため、
   * Arcade Body の checkCollision を切り替える。
   * 目的外の岩では止まらず、目的の岩のヒットボックスに入った瞬間だけ停止。
   */
  preUpdate(time: number, delta: number) {
    super.preUpdate(time, delta);
    // --- 割り込みがあったら、このフレームは何もせず終了 ---
    if (this.interrupted) {
      this.interrupted = false; // ←★ ここで即リセット
      return;
    }

    const body = this.body as Phaser.Physics.Arcade.Body;

    if (this.moveTarget) {

      const dx = this.moveTarget.x - this.x;
      const dy = this.moveTarget.y - this.y;

      // Direction
      if (Math.abs(dx) >= Math.abs(dy)) {
        this.facing = dx >= 0 ? "right" : "left";
        this.direction = dx >= 0 ? 0 : 180;
      } else {
        this.facing = dy >= 0 ? "back" : "forward";
        this.direction = dy >= 0 ? 90 : 270;
      }

      // 速度更新 & アニメ
      const angle = Math.atan2(dy, dx);
      this.scene.physics.velocityFromRotation(angle, this.moveSpeed, body.velocity);
      this.playWalkAnim();

      // ---- ② 目的の岩の当たり判定に触れたら停止 ----
      if (this.targetRock && (this.targetRock.body as Phaser.Physics.Arcade.StaticBody)) {
        const pr = new Phaser.Geom.Rectangle(body.x, body.y, body.width, body.height);
        const rb = this.targetRock.body as Phaser.Physics.Arcade.StaticBody;
        const rr = new Phaser.Geom.Rectangle(rb.x, rb.y, rb.width, rb.height);

        if (Phaser.Geom.Intersects.RectangleToRectangle(pr, rr)) {
          this.stopAutoMove();
          logger.info("Stopped on target rock hitbox.");
        }
      }
    } else {
      // 自動移動していないときは通常の衝突（岩で止まる）に戻す
      if (body.checkCollision.none !== false) body.checkCollision.none = false;
    }

    // カメラが自分を映すようになったらクランプON
    const cam = this.scene.cameras.main;
    if (!this.clampEnabled) {
      if (cam.worldView.contains(this.x, this.y)) {
        this.clampEnabled = true;
      }
      return; // それまでは押し戻さない
    }

    this.keepInsideCameraView();
  }

  /** 自動移動の明示停止API（停止時に衝突判定も元に戻す） */
  public stopAutoMove() {
    const body = this.body as Phaser.Physics.Arcade.Body;
    if (body) {
      body.setVelocity(0, 0);
      body.checkCollision.none = false; // 通常の collider を復帰
    }
    this.moveTarget = null;
    this.targetRock = null;
  }

  public interruptAutoMove() {
    if (this.isAutoMoving()) {
      logger.info("Auto-move interrupted by user input.");
      this.stopAutoMove();
      this.interrupted = true;
    }
  }

  // Player.ts の class Player 内に追加
  private keepInsideCameraView() {
    const body = this.body as Phaser.Physics.Arcade.Body;
    if (!body) return;

    const cam = this.scene.cameras.main;
    // いま画面に映っているワールド領域（スクロール込み）
    const view = cam.worldView;

    // ヒットボックスの“半分”で余白（はみ出しを防ぐ）
    const halfW = body.width  * 0.5;
    const halfH = body.height * 0.5;

    // クランプ先（左/右/上/下）
    const minX = view.left  + halfW;
    const maxX = view.right - halfW;
    const minY = view.top   + halfH;
    const maxY = view.bottom- halfH;

    // 実際に押し戻す
    this.x = Phaser.Math.Clamp(this.x, minX, maxX);
    this.y = Phaser.Math.Clamp(this.y, minY, maxY);

    // 位置を直接いじったので、物理Bodyも同期
    body.position.x = this.x - halfW;
    body.position.y = this.y - halfH;
  }

}
```

<a id="app-src-entities-Rock.ts"></a>
### 25. `app/src/entities/Rock.ts`
- Size: 790 bytes | LOC: 27 | SLOC: 19 | TODOs: 0 | Modified: 2025-10-15 00:35:11 | SHA1: 5bef885fc751

#### Brief
import Phaser from "phaser";

#### Auto Summary
import Phaser from "phaser";

#### Content

```typescript
import Phaser from "phaser";

export class Rock extends Phaser.GameObjects.Rectangle {
  nameTag: Phaser.GameObjects.Text;

  constructor(scene: Phaser.Scene, x: number, y: number, w: number, h: number, name: string) {
    super(scene, x, y, w, h, 0x5b4b3a);
    scene.add.existing(this);

    // 物理(Static Body)
    scene.physics.add.existing(this, true);
    // サイズを矩形に厳密同期（中心基準）
    const body = this.body as Phaser.Physics.Arcade.StaticBody;
    body.setSize(w, h, true);

    // 見た目
    this.setStrokeStyle(2, 0x2b241d, 0.6);
    this.setData("name", name);

    this.nameTag = scene.add.text(x - w / 2, y - h / 2 - 14, name, {
      font: "14px monospace",
      color: "#fff",
      stroke: "#000",
      strokeThickness: 3,
    });
  }
}
```

<a id="app-src-logger.ts"></a>
### 26. `app/src/logger.ts`
- Size: 3278 bytes | LOC: 82 | SLOC: 69 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: ae54cbeb9487

#### Brief
export type LogLevel = "log" | "info" | "warn" | "error" | "cmd";
type Entry = { ts: number; level: LogLevel; msg: string };

#### Auto Summary
export type LogLevel = "log" | "info" | "warn" | "error" | "cmd";

#### Content

```typescript
export type LogLevel = "log" | "info" | "warn" | "error" | "cmd";
type Entry = { ts: number; level: LogLevel; msg: string };

export class OverlayLogger {
  private el: HTMLElement;
  private buf: Entry[] = [];
  private max = 200;
  private visible = true;

  constructor(opts?: { max?: number; captureConsole?: boolean }) {
    if (opts?.max) this.max = opts.max;
    this.el = this.ensureOverlay();
    if (opts?.captureConsole) this.captureConsole();
    window.addEventListener("keydown", (e) => {
      if (e.key === "`") this.toggle();
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "l") {
        e.preventDefault(); this.clear();
      }
    });
  }
  private ensureOverlay() {
    const el = document.getElementById("log") as HTMLPreElement | null;
    if (!el) throw new Error("#log element not found");
    return el;
  }
  
  private captureConsole() {
    const _log = console.log, _info = console.info, _warn = console.warn, _error = console.error;
    console.log = (...a: any[]) => { this.write("log", a.join(" ")); _log(...a); };
    console.info = (...a: any[]) => { this.write("info", a.join(" ")); _info(...a); };
    console.warn = (...a: any[]) => { this.write("warn", a.join(" ")); _warn(...a); };
    console.error = (...a: any[]) => { this.write("error", a.join(" ")); _error(...a); };
  }


  /** ユーザー向け API */
  log(msg: string)  { this.write("log", msg); }
  info(msg: string) { this.write("info", msg); }
  warn(msg: string) { this.write("warn", msg); }
  error(msg: string){ this.write("error", msg); }
  cmd(msg: string)  { this.write("cmd", msg); }

  clear() { this.buf = []; this.render(); }
  toggle() { this.visible = !this.visible; (this.el as any).style.display = this.visible ? "" : "none"; }

  /** コア：バッファ追加 → 上限超過ぶんを破棄 → 逆順で描画（最新が最上段） */
  private write(level: LogLevel, msg: string) {
    this.buf.push({ ts: Date.now(), level, msg });
    if (this.buf.length > this.max) {
      // 先頭（＝最も古い）から削る
      this.buf.splice(0, this.buf.length - this.max);
    }
    this.render();
  }

  private render() {
    // 最新→古い の順に並べて上から描画
    const lines = this.buf
      .slice()            // コピー
      .reverse()          // 逆順（最新が先頭）
      .map(e => this.format(e));
    (this.el as HTMLPreElement).textContent = lines.join("\n");
  }

  private format(e: Entry) {
    // ここは好みで。レベルの装飾など（例： [INFO] など）
    switch (e.level) {
      case "info":  return `[INFO]  ${e.msg}`;
      case "warn":  return `[WARN]  ${e.msg}`;
      case "error": return `[ERROR] ${e.msg}`;
      case "cmd":   return `> ${e.msg}`;
      default:      return e.msg;
    }
  }

  private hhmmss(ts:number){ const d=new Date(ts);
    return `${String(d.getHours()).padStart(2,"0")}:${String(d.getMinutes()).padStart(2,"0")}:${String(d.getSeconds()).padStart(2,"0")}`; }
  private tag(level: LogLevel){
    switch(level){ case "cmd": return "[CMD]"; case "info": return "[INFO]"; case "warn": return "[WARN]"; case "error": return "[ERR ]"; default: return "[LOG ]"; }
  }
}
export const logger = new OverlayLogger({ max: 300, captureConsole: false });
```

<a id="app-src-main.ts"></a>
### 27. `app/src/main.ts`
- Size: 711 bytes | LOC: 27 | SLOC: 21 | TODOs: 0 | Modified: 2025-10-15 01:29:21 | SHA1: 8afd2814d836

#### Brief
import Phaser from "phaser";
import { TitleScene } from "./scenes/TitleScene";

#### Auto Summary
import Phaser from "phaser";

#### Content

```typescript
import Phaser from "phaser";
import { TitleScene } from "./scenes/TitleScene";
import { MainScene } from "./scenes/MainScene";
import { logger } from "./logger";

logger.info("Booting Phaser...");

const BASE_W = 1200;   // 論理解像度（横）
const BASE_H = 900;    // 論理解像度（縦）← 4:3 を維持

const config: Phaser.Types.Core.GameConfig = {
  parent: "game-root",
  type: Phaser.AUTO,
  width: BASE_W,
  height: BASE_H,
  backgroundColor: "#20242a",
  physics: { default: "arcade", arcade: { debug: true } },
  scene: [TitleScene, MainScene],
  scale: {
    mode: Phaser.Scale.FIT,
    // autoCenter: Phaser.Scale.CENTER_BOTH
  },
};

new Phaser.Game(config);

logger.cmd("Initialized");
```

<a id="app-src-scenes-MainScene.ts"></a>
### 28. `app/src/scenes/MainScene.ts`
- Size: 20122 bytes | LOC: 518 | SLOC: 397 | TODOs: 0 | Modified: 2025-10-15 04:29:24 | SHA1: 11d1a234f33a

#### Brief
import Phaser from "phaser";
import { createASR } from "../asr";

#### Auto Summary
import Phaser from "phaser";

#### Content

```typescript
import Phaser from "phaser";
import { createASR } from "../asr";
import { logger } from "../logger";
import { Rock } from "../entities/Rock";
import { Enemy } from "../entities/Enemy";
import { Boss } from "../entities/Boss";
import { Player } from "../entities/Player";
import { Bullet } from '../entities/Bullet';
import { DeathFX } from "../effects/DeathFX";
import { SoundManager } from "../audio/SoundManager";

export class MainScene extends Phaser.Scene {
  private player!: Player;
  private boss!: Boss;
  private bullets!: Phaser.Physics.Arcade.Group; 
  private cursors!: Phaser.Types.Input.Keyboard.CursorKeys;
  private friendlies!: Phaser.Physics.Arcade.Group;
  private enemies!:    Phaser.Physics.Arcade.Group;
  private rocks!:      Phaser.Physics.Arcade.StaticGroup;

  private words_rock = [
    "rock","stone","hill","cliff","sand","dust","mud","cave","valley","island",
    "shore","beach","wave","shell","pebble","boulder","mountain","forest","tree","leaf",
    "root","branch","grass","moss","vine","river","stream","lake","pond","water",
    "ice","snow","frost","storm","cloud","wind","breeze","rain","drop","mist",
    "shadow","light","sun","moon","star","sky","dawn","night","day","twilight",
    "earth","soil","field","plain","plate","ridge","path","trail","step","road",
    "wall","gate","bridge","pillar","arch","ring","circle","cube","crystal","gem",
    "iron","silver","gold","metal","orange","coal","salt","clay","brick","dusty",
    "silent","still","calm","cold","hard","solid","heavy","quiet","deep","rough",
    "wild","lonely","ancient","broken","gray","brown","smooth","soft","sharp","flat"
    ]
  private words_enemy = [
    "fire","flame","smoke","ash","ember","fang","claw","wing","scale","tail",
    "wolf","bear","fox","hawk","snake","rat","crow","bat","boar","owl",
    "ghost","spirit","shade","shadow","demon","devil","beast","ogre","goblin","witch",
    "wizard","soldier","hunter","bandit","pirate","ninja","robot","drone","guard","sniper",
    "viper","wasp","bee","ant","spider","scorpion","hound","lion","tiger","dragon",
    "rage","anger","hate","fear","pain","death","skull","bone","blood","fangs",
    "sword","blade","arrow","gun","bomb","laser","missile","tank","snare","trap",
    "storm","thunder","lightning","spark","blast","toxic","acid","venom","dark","evil",
    "hot","mad","wild","fast","swift","fierce","cruel","sharp","dead","furious",
    "iron","steel","mech","void","warp","curse","doom","burn","bite","crash"
    ]

  wasd!: { [k: string]: Phaser.Input.Keyboard.Key };
  facing: "back" | "left" | "right" | "forward" = "back";

  // === Sprite Sheet ===
  static FRAME_W = 32;
  static FRAME_H = 32;

  // Frame Assignment
  static FRAMES = {
    back:  { idle: 0,  walk: [0, 1, 2] },
    left:  { idle: 3,  walk: [3, 4, 5] },
    right: { idle: 6,  walk: [6, 7, 8] },
    forward:    { idle: 9, walk: [9, 10, 11] },
  };

  // input
  private dir = { forward:false, back:false, left:false, right:false };
  private W = 1200;
  private H = 900;
  private Max_H = 900;
  private X_PLAYER = this.W/2;
  private Y_PLAYER = this.Max_H - this.H/2;

  constructor(){
    super("MainScene");
  }

  preload() {
    this.load.spritesheet('player', 'images/witch_sheet.png', {frameWidth: MainScene.FRAME_W,frameHeight: MainScene.FRAME_H,},);
    this.load.spritesheet('enemy', 'images/enemy_sheet.png', {frameWidth: MainScene.FRAME_W,frameHeight: MainScene.FRAME_H,},);
    this.load.spritesheet('boss', 'images/enemy_sheet.png', {frameWidth: MainScene.FRAME_W,frameHeight: MainScene.FRAME_H,});
    this.load.image("bullet", "images/bullet.png");
    this.load.audio("bgm_main", "audio/bgm.mp3");
    this.load.audio("se_player_die", "audio/character_destroy.mp3");
    this.load.audio("se_enemy_die",  "audio/character_destroy.mp3");
    this.load.audio("se_boss_die",   "audio/character_destroy.mp3");
    this.load.audio("se_bullet_fire",     "audio/bullet_timeout.mp3");
    this.load.audio("se_bullet_timeout",  "audio/bullet_timeout.mp3");
    this.load.audio("se_bullet_collision","audio/bullet_timeout.mp3");
  }

  create() {
    // log
    logger.cmd("GAME START");
    SoundManager.init(this);

    // audio
    const bgm = this.sound.add("bgm_main", { loop: true, volume: 0.4 });
    bgm.play();

    // ground
    this.cameras.main.setBackgroundColor(0x66CDAA);

    // boundary & camera
    this.cameras.main.setBounds(0, 0, this.W, this.Max_H);
    this.physics.world.setBounds(0, 0, this.W, this.Max_H);

    // Player
    this.friendlies = this.physics.add.group({ classType: Player, runChildUpdate: true });
    this.player = new Player(
      this, 
      this.X_PLAYER,
      this.Y_PLAYER,
      "you",
      5);
    this.friendlies.add(this.player);

    this.cursors = this.input.keyboard!.createCursorKeys();
    this.wasd = {
      W: this.input.keyboard!.addKey(Phaser.Input.Keyboard.KeyCodes.W),
      A: this.input.keyboard!.addKey(Phaser.Input.Keyboard.KeyCodes.A),
      S: this.input.keyboard!.addKey(Phaser.Input.Keyboard.KeyCodes.S),
      D: this.input.keyboard!.addKey(Phaser.Input.Keyboard.KeyCodes.D),
      SPACE: this.input.keyboard!.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE),
    } as any;

    // animation
    this.makeWalkAnim("walk-back",    MainScene.FRAMES.back.walk);
    this.makeWalkAnim("walk-left",    MainScene.FRAMES.left.walk);
    this.makeWalkAnim("walk-right",   MainScene.FRAMES.right.walk);
    this.makeWalkAnim("walk-forward", MainScene.FRAMES.forward.walk);
  
    // 発射（スペース）
    this.input.keyboard!.on('keydown-SPACE', () => {
      // 既存チューニングを維持（400, r8, life 1000ms, arm 300ms）
      this.player.shoot(this.player.direction, {
        speed: 400,
        radius: 8,
        lifespanMs: 1000,
        armDelayMs: 300,
      });
    });

    this.cameras.main.startFollow(this.player, true, 0.1, 0.1);

    // Player Input
    const kb = this.input.keyboard!;
    const setKey = (key:string, k:keyof typeof this.dir, v:boolean)=>{
      kb.on(`${v?'keydown':'keyup'}-${key}`, ()=> this.dir[k]=v);
    };
    const logKey = (type:string, key:string)=> logger.cmd(`key ${type}: ${key}`);
    kb.on("keydown", (e: KeyboardEvent) => logKey("back", e.key));
    kb.on("keyup",   (e: KeyboardEvent) => logKey("forward",   e.key));

    // Bullets group
    this.bullets = this.physics.add.group({
      classType: Bullet,
      runChildUpdate: true,
      maxSize: 600,
    });

    // Enemy
    this.enemies = this.physics.add.group({ classType: Enemy, runChildUpdate: true });
    const ENEMY_COUNT = 6;
    for (let i = 0; i < ENEMY_COUNT; i++) {
      const randX = Phaser.Math.Between(100, this.W - 100);
      const randY = Phaser.Math.Between(500, this.Max_H - 200);
      const e = new Enemy(this, randX, randY, this.getUniqueWord(this.words_enemy));
      this.enemies.add(e);
    }
    // === Enemy Attack ===
    this.time.addEvent({
      delay: 2000,
      loop: true,
      callback: () => {
        if (!this.player?.active) return;

        this.enemies.children.each((enemyGO: Phaser.GameObjects.GameObject) => {
          const e = enemyGO as Phaser.Physics.Arcade.Sprite;
          if (!e.active) return;

          const canSee =
            this.inFOVAndRange(e.x, e.y, this.player.x, this.player.y, { fovDeg: 120, range: 700 }) &&
            this.hasLineOfSight(e.x, e.y, this.player.x, this.player.y);

          if (!canSee) return;

          // Shoot
          const ang = Phaser.Math.RadToDeg(
            Phaser.Math.Angle.Between(e.x, e.y, this.player.x, this.player.y)
          );
          (e as any ).shoot(ang, {
            speed: 220,
            radius: 8,
            lifespanMs: 2000,
            armDelayMs: 300,
          });
        });
      },
    });

    // === ランダム岩（障害物） ===
    this.rocks = this.physics.add.staticGroup();

    const ROCK_COUNT = 24; // 岩の数
    const MIN_W = 24, MAX_W = 96; // 幅の最小・最大
    const MIN_H = 24, MAX_HH = 96; // 高さの最小・最大
    const SAFE_RADIUS = 140; // プレイヤー初期位置の安全距離

    const playerSpawn = new Phaser.Math.Vector2(this.player.x, this.player.y);
    const placed: Phaser.Geom.Rectangle[] = []; // 重なり回避用

    const placeRock = (rx: number, ry: number, rw: number, rh: number) => {

      const name = this.getUniqueWord(this.words_rock);
      const rock = new Rock(this, rx, ry, rw, rh, name);
      this.rocks.add(rock);

      placed.push(new Phaser.Geom.Rectangle(rx - rw / 2, ry - rh / 2, rw, rh));
    };
    // ランダム配置ループ
    for (let i = 0; i < ROCK_COUNT; i++) {
      let tries = 0;
      while (tries++ < 25) {
        const rw = Phaser.Math.Between(MIN_W, MAX_W);
        const rh = Phaser.Math.Between(MIN_H, MAX_HH);
        const rx = Phaser.Math.Between(60 + rw/2, this.W - 60 - rw/2);
        const ry = Phaser.Math.Between(200 + rh/2, this.Max_H - 200 - rh/2);

        // プレイヤー初期位置の安全距離を確保
        if (playerSpawn.distance(new Phaser.Math.Vector2(rx, ry)) < SAFE_RADIUS) continue;

        // 既存の岩と簡易重なり回避
        const cand = new Phaser.Geom.Rectangle(rx - rw/2, ry - rh/2, rw, rh);
        const is_overlaps = placed.some(r => Phaser.Geom.Rectangle.Overlaps(r, cand));
        if (is_overlaps) continue;

        placeRock(rx, ry, rw, rh);

        break;
      }
    }

    // === Boss ===
    const bossName = this.getUniqueWord(this.words_enemy);
    this.boss = new Boss(this, this.W * 0.5, 300, bossName, 30);
    this.enemies.add(this.boss);

    // === Boss atack ===
    this.time.addEvent({
      delay: 1500,
      loop: true,
      callback: () => {
        if (!this.boss?.active) return;

      // visibility
      const canSee =
        this.inFOVAndRange(this.boss.x, this.boss.y, this.player.x, this.player.y, { fovDeg: 120, range: 700 }) &&
        this.hasLineOfSight(this.boss.x, this.boss.y, this.player.x, this.player.y);

      if (!canSee) return;

        const angle = Phaser.Math.RadToDeg(
                Phaser.Math.Angle.Between(this.boss.x, this.boss.y,  this.player.x,  this.player.y)
        );
        this.boss.shootSpread(angle, 5, 30, {
                speed: 400,
                radius: 8,
                lifespanMs: 1000,
                armDelayMs: 300,
        });
        this.boss.setWeapon({ armDelayMs: 2500 }); // 0.5秒で武装完了
      },
    });

    // Collision
    // Dynamic × Static
    this.physics.add.collider(this.friendlies,  this.rocks); 
    this.physics.add.collider(this.enemies, this.rocks);
    
    // 4) 弾 × 岩（現状維持：弾だけ消える＝岩は不死）
    this.physics.add.collider(this.bullets, this.rocks, (bGO) => {
      (bGO as Bullet).takeDamage(1);
    });

    // 5) Bullet × Bullet
    this.physics.add.collider(
      this.bullets,
      this.bullets,
      // onCollide: 相殺（両方消す）
      (aGO, bGO) => {
        const a = aGO as Bullet;
        const b = bGO as Bullet;
        // 片方が既に死んでいたら二重処理を避ける
        if (!a.active || !b.active) return;
        a.takeDamage?.(1);
        b.takeDamage?.(1);
      },
      // process: 衝突させるかどうか判定
      (aGO, bGO) => {
        const a = aGO as Bullet;
        const b = bGO as Bullet;

        // 無効・非表示はスキップ
        if (!a.active || !b.active || !a.visible || !b.visible) return false;

        // どちらか非武装なら衝突させない（初期重なり対策）
        if (!a.isArmed?.() || !b.isArmed?.()) return false;

        // 同一 owner (同じシューター) の弾同士は衝突させない
        const ao = a.getOwner?.();
        const bo = b.getOwner?.();
        if (ao && bo && ao === bo) return false;

        // 同一 faction の弾同士も衝突させない（例: "enemy" vs "enemy"）
        const af = a.getData?.("faction");
        const bf = b.getData?.("faction");
        if (af && bf && af === bf) return false;

        // ここまで来たら敵味方の弾。相殺させる
        return true;
      }
    );

    // Enemy Collision
    this.physics.add.overlap(this.bullets, this.enemies, (bGO, eGO) => {
      const b = bGO as Bullet;
      if (!b.isArmed()) return;
      (eGO as any).takeDamage?.(1);
      logger.cmd(`Enemy Hit`)
      b.takeDamage(1);
    });

    // Player Collision
    this.physics.add.overlap(this.bullets, this.friendlies, (bGO, pGO) => {
      const b = bGO as Bullet;
      if (!b.isArmed()) return;
      (pGO as any).takeDamage?.(1);
      logger.cmd(`Player Hit`)
      b.takeDamage(1);
    });

    this.setupMic();

    this.registerInterruptHandlers();
  }

  update() {
    const speed = 200;
    const left    = (this.cursors.left?.isDown  || this.wasd.A.isDown   || this.dir.left);
    const right   = (this.cursors.right?.isDown || this.wasd.D.isDown   || this.dir.right);
    const forward = (this.cursors.up?.isDown    || this.wasd.W.isDown   || this.dir.forward);
    const back    = (this.cursors.down?.isDown  || this.wasd.S.isDown   || this.dir.back);

    // 速度初期化
    for (const friendly of this.friendlies.getChildren()) {
      if ((friendly as any).isAutoMoving?.()) continue; // ★自動移動を尊重
      friendly.setVelocity(0);
      // 入力に応じて速度・向き設定（斜めは最後に押された軸を優先したい場合は工夫可）
      let moving = false;
      if (left)    { friendly.setVelocityX(-speed); this.facing = "left";    moving = true; friendly.direction=180; }
      if (right)   { friendly.setVelocityX( speed); this.facing = "right";   moving = true; friendly.direction=0; }
      if (forward) { friendly.setVelocityY(-speed); this.facing = "forward"; moving = true; friendly.direction=270; }
      if (back)    { friendly.setVelocityY( speed); this.facing = "back";    moving = true; friendly.direction=90; }
      // アニメ再生 or 待機フレーム
      if (moving) {
        friendly.play(`walk-${this.facing}`, true);
      } else {
        // 立ち止まったらその向きのidleフレームで停止
        friendly.anims.stop();
        const idleFrame = MainScene.FRAMES[this.facing].idle;
        friendly.setFrame(idleFrame);
      }
    }

  }

  // ==== ユーティリティ: 歩行アニメを作る ====
  private makeWalkAnim(key: string, frames: number[]) {
    this.anims.create({
      key,
      frames: frames.map((f) => ({ key: "player", frame: f })),
      frameRate: 8,
      repeat: -1,
    });
  }

  private setupMic() {
    const btn = document.getElementById("btnMic") as HTMLButtonElement | null;
    const stat = document.getElementById("micStatus");
    const asr = createASR("en-US");
    if (!btn || !stat) return;
    if (!asr.supported) { stat.textContent = "mic: unsupported (use keys)"; btn.disabled = true; return; }

    let running = false;
    const set = (k: keyof typeof this.dir, val: boolean)=> (this.dir[k] = val);

    btn.onclick = () => {
      if (!running) {
        asr.start((text, isFinal) => {
          const lower = text.toLowerCase();
          if (!isFinal) { stat.textContent = "mic: listening…"; return; }
          // === ターゲット名検出 ===
          this.enemies.children.each((enemyGO: Phaser.GameObjects.GameObject) => {
            const enemy = enemyGO as Enemy;
            const name = enemy.displayName.toLowerCase();
            if (lower.includes(name)) {
              logger.cmd(`🎯 "${name}" detected by voice!`);
              // 散弾発射
              const angle = Phaser.Math.RadToDeg(
                Phaser.Math.Angle.Between(this.player.x, this.player.y, enemy.x, enemy.y)
              );
              this.player.shootSpread(angle, 5, 30, {
                speed: 400,
                radius: 8,
                lifespanMs: 1000,
                armDelayMs: 300,
              });
            }
          });

          this.rocks.children.each((obj: Phaser.GameObjects.GameObject) => {
            const rock = obj as Rock;
            const rockName = (rock.getData("name") as string).toLowerCase();
            if (lower.includes(rockName)) {
              logger.cmd(`Voice detected rock "${rockName}"`);
              this.player.moveToRock(rock);
            }
          });

          logger.cmd(`voice: ${lower}`);

          // 移動（押下状態を切替）
          if (/\bforward\b/.test(lower)) { set("forward", true);  set("back",false); set("left",false); set("right",false); }
          if (/\bback\b/.test(lower))    { set("forward", false); set("back",true);  set("left",false); set("right",false); }
          if (/\bleft\b/.test(lower))    { set("forward", false); set("back",false); set("left",true);  set("right",false); }
          if (/\bright\b/.test(lower))   { set("forward", false); set("back",false); set("left",false); set("right",true); }
          if (/\bstop\b/.test(lower))    { set("forward", false); set("back",false); set("left",false); set("right",false); }

          // “shoot” 単独なら最後に動いた向きへ
          if (/\bshoot\b/.test(lower) && !/\bshoot (left|right|forward|back)\b/.test(lower)) {
            this.player.shoot(this.player.direction, {
              speed: 400,
              radius: 8,
              lifespanMs: 1000,
              armDelayMs: 300,
            });
          }
        });
        running = true; btn.textContent = "⏹ Stop mic"; stat.textContent = "mic: listening…";
      } else {
        asr.stop(); running = false; btn.textContent = "🎤 Start mic"; stat.textContent = "mic: idle";
      }
    };

  }

  // === LoS / FOV / Range ===
  private hasLineOfSight(ax: number, ay: number, bx: number, by: number): boolean {
    const ray = new Phaser.Geom.Line(ax, ay, bx, by);
    let blocked = false;
    this.rocks.children.iterate((go: Phaser.GameObjects.GameObject) => {
      if (blocked) return;
      const r = go as Phaser.GameObjects.Rectangle;
      const rect = new Phaser.Geom.Rectangle(r.x - r.width/2, r.y - r.height/2, r.width, r.height);
      if (Phaser.Geom.Intersects.LineToRectangle(ray, rect)) blocked = true;
    });
    return !blocked;
  }

  private inFOVAndRange(ex: number, ey: number, px: number, py: number, opts?: {
    fovDeg?: number; range?: number;
  }): boolean {
    const fovDeg = opts?.fovDeg ?? 100; // 視野角（例：±50°）
    const range  = opts?.range ?? 600;  // 射程
    const dx = px - ex, dy = py - ey;
    const dist = Math.hypot(dx, dy);
    if (dist > range) return false;

    // 敵の「向き」は未管理なので、敵→プレイヤー方向ベクトルをそのまま視線とみなす
    //（向き管理したいなら敵の回転等に合わせて angleDiff を計算）
    // ここではFOVは実質「どの方向でもOK」に近いが、将来の向き実装に備えて残す
    const angleToPlayer = Phaser.Math.Angle.Normalize(Math.atan2(dy, dx));
    const angleForward  = angleToPlayer; // 簡略：前方＝プレイヤー方向
    const angDiff = Phaser.Math.RadToDeg(Phaser.Math.Angle.Wrap(angleToPlayer - angleForward));
    return Math.abs(angDiff) <= fovDeg * 0.5;
  }

  private getUniqueWord(pool: string[]): string {
    if (pool.length === 0) return "none";
    const i = Phaser.Math.Between(0, pool.length - 1);
    return pool.splice(i, 1)[0];
  }

  public spawnBullet(
    x: number, y: number,
    angleDeg: number,
    speed = 500,
    radius = 8,
    lifeMs = 3000,
    armDelayMs = 300
  ) {
    const b = this.bullets.get(x, y, "bullet", 0, true) as Bullet | null;
    if (!b) return null;
    b.setActive(true).setVisible(true);
    b.configure({ speed, radius, lifespanMs: lifeMs, armDelayMs });

    const body = b.body as Phaser.Physics.Arcade.Body;
    body.enable = true;
    body.reset(x, y);
    b.fire(angleDeg, speed);
    return b;
  }

  private registerInterruptHandlers() {
    this.input.keyboard!.on('keydown', (e: KeyboardEvent) => {
      if (this.player.isAutoMoving()) {
        this.player.interruptAutoMove();
      }
    });

  }
}
```

<a id="app-src-scenes-TitleScene.ts"></a>
### 29. `app/src/scenes/TitleScene.ts`
- Size: 9762 bytes | LOC: 259 | SLOC: 198 | TODOs: 0 | Modified: 2025-10-15 01:20:43 | SHA1: 6ecd4571c57e

#### Brief
import Phaser from "phaser";

#### Auto Summary
import Phaser from "phaser";

#### Content

```typescript
import Phaser from "phaser";

export class TitleScene extends Phaser.Scene {
  private bgm!: Phaser.Sound.BaseSound;
  private bg!: Phaser.GameObjects.Image;
  private scrim!: Phaser.GameObjects.Graphics;
  private vignette!: Phaser.GameObjects.Graphics;

  // UI
  private uiContainer!: Phaser.GameObjects.Container;
  private titleText!: Phaser.GameObjects.Text;
  private subtitleText!: Phaser.GameObjects.Text;
  private hintText!: Phaser.GameObjects.Text;

  constructor() {
    super("TitleScene");
  }

  preload() {
    // 既存: タイトルBGMと背景
    this.load.audio("audio_title", "audio/title.mp3");
    this.load.image("title_bg", "images/title.png");
    this.load.audio("se_bullet_collision","audio/bullet_timeout.mp3");
  }

  create() {
    const w = this.scale.width, h = this.scale.height;

    // BGM
    this.bgm = this.sound.add("audio_title", { loop: true, volume: 0.4 });
    this.bgm.play();

    // 背景（coverで全面）
    this.bg = this.add.image(w / 2, h / 2, "title_bg").setOrigin(0.5, 0.5);
    this.bg.setScrollFactor(0);
    this.fitCover(this.bg, w, h);

    // 画像の上に半透明のスクリーン（文字のコントラスト確保）
    this.scrim = this.add.graphics().setScrollFactor(0).setDepth(5);
    this.drawScrim(this.scrim, w, h, 0.38);

    // ソフトなビネット（端を暗くして中央を目立たせる）
    this.vignette = this.add.graphics().setScrollFactor(0).setDepth(6);
    this.drawVignette(this.vignette, w, h);

    // ====== タイトル／メニュー（前面UI） ======
    this.uiContainer = this.add.container(0, 0).setDepth(10);

    const { titleSize, subSize, hintSize, columnY } = this.computeLayout(w, h);

    // タイトル
    this.titleText = this.add.text(w / 2, columnY - 40, "Magic & Movement", {
      fontFamily: "monospace",
      fontSize: `${titleSize}px`,
      color: "#ffffff",
      stroke: "#000000",
      strokeThickness: Math.max(4, Math.round(titleSize * 0.15)),
    })
      .setOrigin(0.5)
      .setShadow(0, Math.max(2, Math.round(titleSize * 0.06)), "#000", Math.max(8, Math.round(titleSize * 0.25)), true, true);
    this.uiContainer.add(this.titleText);

    // サブタイトル
    this.subtitleText = this.add.text(w / 2, columnY + 10, "Say names or press keys", {
      fontFamily: "monospace",
      fontSize: `${subSize}px`,
      color: "#dfe9ff",
      stroke: "#000000",
      strokeThickness: Math.max(3, Math.round(subSize * 0.18)),
    })
      .setOrigin(0.5)
      .setShadow(0, Math.max(2, Math.round(subSize * 0.08)), "#000", Math.max(6, Math.round(subSize * 0.3)), true, true);
    this.uiContainer.add(this.subtitleText);

    // メニュー群
    const menuY = columnY + 70;
    const spacing = Math.max(12, Math.round(h * 0.015));
    const buttonWidth = Math.min(520, Math.round(w * 0.6));
    const buttonHeight = Math.max(44, Math.round(h * 0.06));
    const labelSize = Math.max(16, Math.round(buttonHeight * 0.42));

    const startBtn = this.makeButton(w / 2, menuY, buttonWidth, buttonHeight, "▶ Start", () => this.startGame(), labelSize);
    const optionsBtn = this.makeButton(w / 2, menuY + (buttonHeight + spacing), buttonWidth, buttonHeight, "Options", () => this.flashHint(), labelSize);

    this.uiContainer.add([startBtn, optionsBtn]);

    // 既存のヒント文（スペース／クリック）
    this.hintText = this.add.text(w / 2, h - Math.max(24, Math.round(h * 0.04)), "Press SPACE / Click / Tap to Start", {
      fontFamily: "monospace",
      fontSize: `${hintSize}px`,
      color: "#eeeeee",
      stroke: "#000000",
      strokeThickness: Math.max(2, Math.round(hintSize * 0.2)),
    })
      .setOrigin(0.5)
      .setShadow(0, Math.max(1, Math.round(hintSize * 0.1)), "#000", Math.max(4, Math.round(hintSize * 0.3)), true, true)
      .setDepth(10);

    // 入力イベント（従来仕様）
    const start = () => this.startGame();
    this.input.keyboard!.on("keydown-SPACE", start);
    this.input.on("pointerdown", start);

    // リサイズ追従
    this.scale.on("resize", (gameSize: Phaser.Structs.Size) => {
      const { width, height } = gameSize;
      this.onResize(width, height);
    });
  }

  // ===== helpers =====
  private startGame() {
    if (this.bgm?.isPlaying) this.bgm.stop();
    this.input.keyboard!.removeAllListeners();
    this.input.removeAllListeners();
    this.scene.start("MainScene");
  }

  private flashHint() {
    // ひとまず未実装メニュー用の簡単なフィードバック
    this.tweens.add({
      targets: this.hintText,
      alpha: 0.2,
      duration: 120,
      yoyo: true,
      repeat: 1,
      ease: "sine.inOut",
    });
  }

  private fitCover(img: Phaser.GameObjects.Image, targetW: number, targetH: number) {
    const tex = this.textures.get(img.texture.key).getSourceImage() as HTMLImageElement;
    const iw = tex?.width ?? 0, ih = tex?.height ?? 0;
    if (!iw || !ih) return;
    const scale = Math.max(targetW / iw, targetH / ih);
    img.setScale(scale).setPosition(targetW / 2, targetH / 2);
  }

  private drawScrim(g: Phaser.GameObjects.Graphics, w: number, h: number, alpha = 0.35) {
    g.clear();
    g.fillStyle(0x000000, alpha);
    g.fillRect(0, 0, w, h);
  }

  // 簡易ビネット（枠を数回描画して周辺を暗く）
  private drawVignette(g: Phaser.GameObjects.Graphics, w: number, h: number) {
    g.clear();
    const rings = 6;
    for (let i = 0; i < rings; i++) {
      const pad = i * Math.max(6, Math.round(Math.min(w, h) * 0.01));
      const a = 0.12 - i * (0.12 / rings);
      if (a <= 0) break;
      g.lineStyle(Math.max(12, Math.round(Math.min(w, h) * 0.02)), 0x000000, a);
      g.strokeRect(pad, pad, w - pad * 2, h - pad * 2);
    }
  }

  private computeLayout(w: number, h: number) {
    const titleSize = Math.max(28, Math.round(h * 0.085));
    const subSize = Math.max(14, Math.round(h * 0.035));
    const hintSize = Math.max(12, Math.round(h * 0.03));
    const columnY = Math.round(h * 0.36);
    return { titleSize, subSize, hintSize, columnY };
  }

  private makeButton(
    x: number,
    y: number,
    w: number,
    h: number,
    label: string,
    onClick: () => void,
    fontPx: number
  ) {
    const bg = this.add.rectangle(0, 0, w, h, 0x000000, 0.45)
      .setStrokeStyle(2, 0xffffff, 0.2)
      .setOrigin(0.5)
      .setInteractive({ useHandCursor: true });

    const text = this.add.text(0, 0, label, {
      fontFamily: "monospace",
      fontSize: `${fontPx}px`,
      color: "#ffffff",
      stroke: "#000000",
      strokeThickness: Math.max(2, Math.round(fontPx * 0.18)),
    })
      .setOrigin(0.5)
      .setShadow(0, Math.max(1, Math.round(fontPx * 0.1)), "#000", Math.max(4, Math.round(fontPx * 0.3)), true, true);

    const c = this.add.container(x, y, [bg, text]);

    // hover / press
    bg.on("pointerover", () => bg.setFillStyle(0x000000, 0.62));
    bg.on("pointerout",  () => bg.setFillStyle(0x000000, 0.45));
    bg.on("pointerdown", () => {
      this.sound.play("se_bullet_collision", { volume: 0.5 });
      bg.setFillStyle(0xffffff, 0.18);
    });
    bg.on("pointerup",   () => {
      bg.setFillStyle(0x000000, 0.62);
      onClick();
    });

    return c;
  }

  private onResize(w: number, h: number) {
    // 背景とオーバーレイをリレイアウト
    this.fitCover(this.bg, w, h);
    this.drawScrim(this.scrim, w, h, 0.38);
    this.drawVignette(this.vignette, w, h);

    // テキスト・ボタンのスケール/位置を再計算
    const { titleSize, subSize, hintSize, columnY } = this.computeLayout(w, h);

    this.titleText
      .setFontSize(titleSize)
      .setStroke("#000", Math.max(4, Math.round(titleSize * 0.15)))
      .setShadow(0, Math.max(2, Math.round(titleSize * 0.06)), "#000", Math.max(8, Math.round(titleSize * 0.25)), true, true)
      .setPosition(w / 2, columnY - 40);

    this.subtitleText
      .setFontSize(subSize)
      .setStroke("#000", Math.max(3, Math.round(subSize * 0.18)))
      .setShadow(0, Math.max(2, Math.round(subSize * 0.08)), "#000", Math.max(6, Math.round(subSize * 0.3)), true, true)
      .setPosition(w / 2, columnY + 10);

    // メニューはコンテナ内の相対配置を再構築せず、Y原点の基準だけ調整
    const spacing = Math.max(12, Math.round(h * 0.015));
    const buttonWidth = Math.min(520, Math.round(w * 0.6));
    const buttonHeight = Math.max(44, Math.round(h * 0.06));
    const labelSize = Math.max(16, Math.round(buttonHeight * 0.42));
    const menuY = columnY + 70;

    // 子要素は [start, howto, options] の順で入れている
    const [startBtn, howtoBtn, optionsBtn] = this.uiContainer.list.filter(n => n instanceof Phaser.GameObjects.Container) as Phaser.GameObjects.Container[];

    const reframe = (btn: Phaser.GameObjects.Container, i: number) => {
      btn.setPosition(w / 2, menuY + i * (buttonHeight + spacing));
      // 背景矩形とラベルを更新
      const rect = btn.list[0] as Phaser.GameObjects.Rectangle;
      const label = btn.list[1] as Phaser.GameObjects.Text;
      rect.setSize(buttonWidth, buttonHeight);
      label.setFontSize(labelSize)
           .setStroke("#000", Math.max(2, Math.round(labelSize * 0.18)))
           .setShadow(0, Math.max(1, Math.round(labelSize * 0.1)), "#000", Math.max(4, Math.round(labelSize * 0.3)), true, true);
    };

    reframe(startBtn, 0);
    reframe(howtoBtn, 1);
    reframe(optionsBtn, 2);

    this.hintText
      .setFontSize(hintSize)
      .setStroke("#000", Math.max(2, Math.round(hintSize * 0.2)))
      .setShadow(0, Math.max(1, Math.round(hintSize * 0.1)), "#000", Math.max(4, Math.round(hintSize * 0.3)), true, true)
      .setPosition(w / 2, h - Math.max(24, Math.round(h * 0.04)));
  }
}
```

<a id="app-src-style.css"></a>
### 30. `app/src/style.css`
- Size: 1525 bytes | LOC: 98 | SLOC: 85 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: 0a7e82ceb45b

#### Brief
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;

#### Auto Summary
:root {

#### Content

```css
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

#app {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.vanilla:hover {
  filter: drop-shadow(0 0 2em #3178c6aa);
}

.card {
  padding: 2em;
}


.read-the-docs {
  color: #888;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}
```

<a id="app-src-typescript.svg"></a>
### 31. `app/src/typescript.svg`
- Size: 1435 bytes | LOC: 1 | SLOC: 1 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: f15a725e7a29

#### Brief
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="32" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 256"><path fill="#007ACC" d="M0 128v128h256V0H0z"></path><path fill="#FFF" d="m56.612 128.85l-.081 10.483h33.32v94.68h23.568v-94.68h33.321v-10.28c0-5.69-.122-10.444-.284-10.566c-.122-.162-20.4-.244-44.983-.203l-44.74.122l-.121 10.443Zm149.955-10.742c6.501 1.625 11.459 4.51 16.01 9.224c2.357 2.52 5.851 7.111 6.136 8.208c.08.325-11.053 7.802-17.798 11.988c-.244.162-1.22-.894-2.317-2.52c-3.291-4.795-6.745-6.867-12.028-7.233c-7.76-.528-12.759 3.535-12.718 10.321c0 1.992.284 3.17 1.097 4.795c1.707 3.536 4.876 5.649 14.832 9.956c18.326 7.883 26.168 13.084 31.045 20.48c5.445 8.249 6.664 21.415 2.966 31.208c-4.063 10.646-14.14 17.879-28.323 20.276c-4.388.772-14.79.65-19.504-.203c-10.28-1.828-20.033-6.908-26.047-13.572c-2.357-2.6-6.949-9.387-6.664-9.874c.122-.163 1.178-.813 2.356-1.504c1.138-.65 5.446-3.129 9.509-5.485l7.355-4.267l1.544 2.276c2.154 3.29 6.867 7.801 9.712 9.305c8.167 4.307 19.383 3.698 24.909-1.26c2.357-2.153 3.332-4.388 3.332-7.68c0-2.966-.366-4.266-1.91-6.501c-1.99-2.845-6.054-5.242-17.595-10.24c-13.206-5.69-18.895-9.224-24.096-14.832c-3.007-3.25-5.852-8.452-7.03-12.8c-.975-3.617-1.22-12.678-.447-16.335c2.723-12.76 12.353-21.659 26.25-24.3c4.51-.853 14.994-.528 19.424.569Z"></path></svg>

#### Auto Summary
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="32" height="32" preserveAspectRatio="xMidYMid mee

#### Content

```
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="32" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 256"><path fill="#007ACC" d="M0 128v128h256V0H0z"></path><path fill="#FFF" d="m56.612 128.85l-.081 10.483h33.32v94.68h23.568v-94.68h33.321v-10.28c0-5.69-.122-10.444-.284-10.566c-.122-.162-20.4-.244-44.983-.203l-44.74.122l-.121 10.443Zm149.955-10.742c6.501 1.625 11.459 4.51 16.01 9.224c2.357 2.52 5.851 7.111 6.136 8.208c.08.325-11.053 7.802-17.798 11.988c-.244.162-1.22-.894-2.317-2.52c-3.291-4.795-6.745-6.867-12.028-7.233c-7.76-.528-12.759 3.535-12.718 10.321c0 1.992.284 3.17 1.097 4.795c1.707 3.536 4.876 5.649 14.832 9.956c18.326 7.883 26.168 13.084 31.045 20.48c5.445 8.249 6.664 21.415 2.966 31.208c-4.063 10.646-14.14 17.879-28.323 20.276c-4.388.772-14.79.65-19.504-.203c-10.28-1.828-20.033-6.908-26.047-13.572c-2.357-2.6-6.949-9.387-6.664-9.874c.122-.163 1.178-.813 2.356-1.504c1.138-.65 5.446-3.129 9.509-5.485l7.355-4.267l1.544 2.276c2.154 3.29 6.867 7.801 9.712 9.305c8.167 4.307 19.383 3.698 24.909-1.26c2.357-2.153 3.332-4.388 3.332-7.68c0-2.966-.366-4.266-1.91-6.501c-1.99-2.845-6.054-5.242-17.595-10.24c-13.206-5.69-18.895-9.224-24.096-14.832c-3.007-3.25-5.852-8.452-7.03-12.8c-.975-3.617-1.22-12.678-.447-16.335c2.723-12.76 12.353-21.659 26.25-24.3c4.51-.853 14.994-.528 19.424.569Z"></path></svg>
```

<a id="app-src-utils-hitbox.ts"></a>
### 32. `app/src/utils/hitbox.ts`
- Size: 1882 bytes | LOC: 52 | SLOC: 33 | TODOs: 0 | Modified: 2025-10-15 03:31:14 | SHA1: 95a0f0ff3ebb

#### Brief
utils/hitbox.ts

#### Auto Summary
// utils/hitbox.ts

#### Content

```typescript
// utils/hitbox.ts
import Phaser from "phaser";

/**
 * 見た目（スケール・フレーム・オリジン適用後）の中心と
 * 物理ボディの中心を「必ず」一致させる。
 * - 丸: 最小辺ベースの円
 * - 角: 矩形
 */
export function syncHitboxToDisplay(
  obj: Phaser.Types.Physics.Arcade.SpriteWithDynamicBody,
  opts: { hitboxShape?: "circle" | "rect"; scaleFactor?: number; padding?: number } = {}
) {
  const hitboxShape = opts.hitboxShape ?? "circle";
  const scaleFactor = opts.scaleFactor ?? 1.0;
  const padding     = opts.padding ?? 0;

  // 表示サイズ（scale 済み）
  const wDisp = Math.max(1, obj.displayWidth  - padding * 2);
  const hDisp = Math.max(1, obj.displayHeight - padding * 2);

  const body = obj.body as Phaser.Physics.Arcade.Body;

  if (hitboxShape === "circle") {
    const r = Math.max(1, (Math.min(wDisp, hDisp) * scaleFactor) * 0.5);

    // ① まず半径だけセット（サイズは r*2 に）
    body.setCircle(r);

    // ② スプライトの表示上の中心（ピクセル）
    const dOx = obj.displayOriginX;         // = displayWidth * originX
    const dOy = obj.displayOriginY;         // = displayHeight * originY

    // ③ body の中心をスプライト中心に一致させる
    //    → offset は「スプライト左上から body 左上まで」の差
    body.setOffset(dOx - r, dOy - r);
  } else {
    const bw = Math.max(1, wDisp * scaleFactor);
    const bh = Math.max(1, hDisp * scaleFactor);

    // ① サイズだけセット（center=true は使わない）
    body.setSize(bw, bh);

    // ② 表示中心に合わせて offset を決め打ち
    const dOx = obj.displayOriginX;
    const dOy = obj.displayOriginY;
    body.setOffset(dOx - bw * 0.5, dOy - bh * 0.5);
  }

  // 最終同期（位置ズレの温床を断つ）
  body.updateFromGameObject();
}
```

<a id="app-src-utils-projectile.ts"></a>
### 33. `app/src/utils/projectile.ts`
- Size: 1234 bytes | LOC: 36 | SLOC: 28 | TODOs: 0 | Modified: 2025-10-15 03:09:41 | SHA1: 391a1755ffd9

#### Brief
utils/projectile.ts

#### Auto Summary
// utils/projectile.ts

#### Content

```typescript
// utils/projectile.ts
export interface HasBodyAndAngle {
  x: number;
  y: number;
  angle?: number;        // 度
  rotation?: number;     // ラジアン
  body?: { width?: number; height?: number; radius?: number };
}

/** シューター中心から「銃口（前方）」の生成位置を返す */
export function getMuzzleSpawn(
  shooter: HasBodyAndAngle,
  angleDeg: number,              // 弾の発射角（度）
  bulletRadius: number,          // 弾の見た目/当たり半径
  padding = 2                    // 余白(ピクセル)
): { x: number; y: number } {
  // シューターの“当たり半径”を概算（矩形でも円でもOK）
  const w = shooter.body?.width ?? 0;
  const h = shooter.body?.height ?? 0;
  const shooterHitRadius =
    shooter.body?.radius ??
    Math.max(w, h) * 0.5 || 12; // 幅高さ不明な場合のフォールバック

  // 射出方向（単位ベクトル）
  const rad = (angleDeg * Math.PI) / 180;
  const dx = Math.cos(rad);
  const dy = Math.sin(rad);

  // 銃口までの距離：シューター半径＋弾半径＋ε
  const muzzle = shooterHitRadius + bulletRadius + padding;

  return {
    x: shooter.x + dx * muzzle,
    y: shooter.y + dy * muzzle,
  };
}
```

<a id="app-tsconfig.json"></a>
### 34. `app/tsconfig.json`
- Size: 637 bytes | LOC: 26 | SLOC: 24 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: af1f75a8015c

#### Brief
{
  "compilerOptions": {

#### Auto Summary
{

#### Content

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "types": ["vite/client"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
```

<a id="Dockerfile"></a>
### 35. `Dockerfile`
- Size: 82 bytes | LOC: 6 | SLOC: 5 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: c5038ca61dc6

#### Brief
FROM node:20-bullseye

#### Auto Summary
FROM node:20-bullseye

#### Content

```dockerfile
FROM node:20-bullseye

WORKDIR /app
COPY app/package*.json ./
RUN npm ci
COPY . .
```

<a id="README.md"></a>
### 36. `README.md`
- Size: 415 bytes | LOC: 3 | SLOC: 2 | TODOs: 0 | Modified: 2025-10-14 16:58:27 | SHA1: b6520e02cb37

#### Brief
# [Shout and Movement](https://github.com/europanite/shout "Shout and Movement")

#### Auto Summary
[Shout and Movement](https://github.com/europanite/shout "Shout and Movement")

#### Content (verbatim)

```markdown
# [Shout and Movement](https://github.com/europanite/shout "Shout and Movement")

英単語を話して、コマンド入力し、キャラクターを動かす。モデルはFire and Movementである。2人の魔法少女がキャラクターが交互に敵を制圧しながら、縦長の世界を前進し、敵を倒していく。日本人が苦手な発音を使いわけることを目的としている。
```
